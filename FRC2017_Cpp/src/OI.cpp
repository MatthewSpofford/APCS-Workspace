// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Commands/ShoverPosition.h"
#include "Commands/AutoGearSides.h"
#include "OI.h"

#include "SmartDashboard/SmartDashboard.h"
#include "Commands/AutonomousCommand.h"
#include "Commands/Drive.h"
#include "Commands/ManualPlaceGear.h"
#include "Commands/MoveToGear.h"
#include "Commands/ParallelToWall.h"
#include "Commands/ParallelToWallWithGyro.h"
#include "Commands/TurnToAngle.h"
#include "Commands/climbWinch.h"
#include "Commands/departFromLift.h"
#include "Commands/dumpToggle.h"
#include "Commands/intakeBalls.h"
#include "Commands/openGate.h"
#include "Commands/closeGate.h"
#include "Commands/pushGear.h"
#include "Commands/reconfigEncoder.h"
#include "Commands/tempCommand.h"
#include "Commands/unwindWinch.h"

#include "Commands/DumpBalls.h"
#include "Commands/toggleDriveMode.h"
#include "Commands/AutoGearMiddle.h"
#include "Commands/ClimberCentric.h"
#include "Commands/flush.h"
#include "Commands/shoot.h"

OI::OI() {
    // Process operator interface input here.
//    xboxController.reset(new Joystick(2));
//
//    selectButton.reset(new JoystickButton(xboxController.get(), 8));
//    selectButton->WhenPressed(new pushGear(false));
//    leftBumper.reset(new JoystickButton(xboxController.get(), 6));
//    leftBumper->WhenPressed(new closeGate(false));
//    rightBumper.reset(new JoystickButton(xboxController.get(), 5));
//    rightBumper->WhenPressed(new openGate(false));
//    joystickButton2.reset(new JoystickButton(xboxController.get(), 10));
//    joystickButton2->WhenPressed(new tempCommand());
//    yButton.reset(new JoystickButton(xboxController.get(), 4));
//    yButton->WhileHeld(new climbWinch());
//    joystickButton1.reset(new JoystickButton(xboxController.get(), 9));
//    joystickButton1->WhenPressed(new tempCommand());
////    aButton.reset(new JoystickButton(xboxController.get(), 1));
////    aButton->WhileHeld(new unwindWinch());
////    startButton.reset(new JoystickButton(xboxController.get(), 1));
////    startButton->WhileHeld(new DumpBalls());
    rightJoystick.reset(new Joystick(1));
    
    leftJoystick.reset(new Joystick(0));
    
    recalibrateWheels.reset(new JoystickButton(leftJoystick.get(), 11));
    recalibrateWheels->WhileHeld(new reconfigEncoder());
//
//    positionPusher.reset(new JoystickButton(xboxController.get(), 2));
//    positionPusher->WhenPressed(new ShoverPosition());
//
//    //Assigned to the A button on the controller
//    shootButton.reset(new JoystickButton(xboxController.get(), 1));
//    shootButton->WhileHeld(new shoot());
//
//    // SmartDashboard Buttons
//    SmartDashboard::PutData("dumpToggle", new DumpBalls());
//    SmartDashboard::PutData("intakeBalls", new intakeBalls());
//
////    SmartDashboard::PutData("pushGear: buttonPress", new pushGear(false));
////    SmartDashboard::PutData("closeGate: buttonPress", new closeGate(false));
////    SmartDashboard::PutData("openGate: buttonPress", new openGate(false));
//
//    SmartDashboard::PutData("pushGear: buttonPress", new pushGear(false));
//    SmartDashboard::PutData("closeGate: buttonPress", new closeGate(false));
//    SmartDashboard::PutData("openGate: buttonPress", new openGate(false));
//    //SmartDashboard::PutData("TurnToAngle", new TurnToAngle(90, true));
//    SmartDashboard::PutData("ParallelToWallWithGyro", new ParallelToWallWithGyro(14, true));
//    //true for teleop testing, false for auto testing --> teleop testing, place the robot at an angle close to 60, -60, or 0
//    //depending on which lift you want to test
//    //auto testing, just change the autonomous position
//    SmartDashboard::PutData("departFromLift", new departFromLift());
//    SmartDashboard::PutData("reconfigEncoder", new reconfigEncoder());
//    SmartDashboard::PutData("ParallelToWall", new ParallelToWall());
//    SmartDashboard::PutData("tempCommand", new tempCommand());
//    SmartDashboard::PutData("unwindWinch", new unwindWinch());
//    SmartDashboard::PutData("climbWinch", new climbWinch());
//    SmartDashboard::PutData("Drive", new Drive());
//    SmartDashboard::PutData("Autonomous Command", new AutonomousCommand());
//
//    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
//
//    SmartDashboard::PutData("pushGear", new pushGear(false));
//    SmartDashboard::PutData("closeGate", new closeGate(false));
//    SmartDashboard::PutData("openGate", new openGate(false));
//    SmartDashboard::PutData("AutoGearMiddle", new AutoGearMiddle());
//    SmartDashboard::PutData("AutoGearSides", new AutoGearSides());
//
//    centricModeToggle.reset(new JoystickButton(leftJoystick.get(), 7));
//    centricModeToggle->WhenPressed(new toggleDriveMode());
//
//    SmartDashboard::PutData("TurnToAngle", new TurnToAngle(90, false));
//
//    controller.reset(new XboxController(2));
//
//    flushButton.reset(new JoystickButton(leftJoystick.get(), 2));
//    flushButton->WhileHeld(new flush());

    //climberModeHold.reset(new JoystickButton(leftJoystick.get(), 1));
    //climberModeHold->WhileHeld(new ClimberCentric());

}

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=FUNCTIONS

std::shared_ptr<Joystick> OI::getLeftJoystick() {
   return leftJoystick;
}

std::shared_ptr<Joystick> OI::getRightJoystick() {
   return rightJoystick;
}

std::shared_ptr<Joystick> OI::getxboxController() {
   return xboxController;
}


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=FUNCTIONS

bool OI::GetButton9()
{
	return joystickButton1->Get();
}

bool OI::GetButton10()
{
	return joystickButton2->Get();
}

bool OI::GetStartButton()
{
	return startButton->Get();
}

bool OI::GetRightTriggerPressed()
{
	double currentState = controller->GetTriggerAxis(frc::GenericHID::JoystickHand::kRightHand);
	SmartDashboard::PutNumber("Right Trigger Val", currentState);
	if(currentState >= 0.85)
	{
		return true;
	}
	else
	{
		return false;
	}
}

void OI::rumble(double value)
{
	controller->SetRumble(XboxController::RumbleType::kLeftRumble, value);
	controller->SetRumble(XboxController::RumbleType::kRightRumble, value);
}

double OI::GetClimberSpeed(const double MIN_SPEED)
{
	double value = -controller->GetTriggerAxis(frc::GenericHID::kLeftHand);
	if(GetButton9())
	{
		if(value < 0)
			return MIN_SPEED;
		else
		{
			if(value < 0.2)
				return 0.2;
			else
				return ((1 - MIN_SPEED) * value) + MIN_SPEED;
		}
	}
	else
		return 0.2;
}

bool OI::GetPushButton()
{
	static bool prevState = false;
	bool currentState = positionPusher->Get();

	if(!prevState && currentState)
		return true;
	else
		return false;

	prevState = currentState;
}
