// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Robot.h"
#include "pixy/pixyPacket.h"
#include "Timer.h"
#include "Commands/AutoGearMiddle.h"
#include "Commands/AutoGearSides.h"
#include "Commands/DriveForward.h"
#include "Commands/AutoPlaceGearCrossBaseline_Sides.h"
#include "Commands/AutoPlaceGearCrossBaseline_Middle.h"
#include "Commands/AutoPlaceGearDumpBalls.h"
#include "Commands/AutoDump.h"
#include "Commands/AutoHopperBlue.h"
#include "Commands/AutoHopperRed.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION
std::shared_ptr<Intake> Robot::intake;
std::shared_ptr<Climber> Robot::climber;
std::shared_ptr<GearPickup> Robot::gearPickup;
std::shared_ptr<Drivetrain> Robot::drivetrain;
std::shared_ptr<Dumpster> Robot::dumpster;
std::unique_ptr<OI> Robot::oi;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION
std::shared_ptr<DigitalInput> Robot::distanceEncoder;
std::shared_ptr<Counter> Robot::distanceCounter;
std::shared_ptr<Shooter> Robot::shooter;

bool Robot::StopCommands;
int Robot::autoPosition;
int Robot::autoMode;
int Robot::alliance;
int Robot::lastValue;
double Robot::distance;
FILE* Robot::turnFile;

void Robot::RobotInit() {

	RobotMap::init();
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
//	intake.reset(new Intake());
//	climber.reset(new Climber());
//    gearPickup.reset(new GearPickup());
    drivetrain.reset(new Drivetrain());
//    dumpster.reset(new Dumpster());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
//    shooter.reset(new Shooter());
//    StopCommands = false;

	// This MUST be here. If the OI creates Commands (which it very likely
	// will), constructing it during the construction of CommandBase (from
	// which commands extend), subsystems are not guaranteed to be
	// yet. Thus, their requires() statements may grab null pointers. Bad
	// news. Don't move it.

	oi.reset(new OI());
//	printf("%s:%d",__FILE__, __LINE__);
	// instantiate the command used for the autonomous period
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
//	autonomousCommand.reset(new AutonomousCommand());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS

//	turnFile = fopen("/tmp/TurnFile.log", "w");
//	alliance = 2;
  }

/**
 * This function is called when the disabled button is hit.
 * You can use it to reset subsystems before shutting down.
 */
void Robot::DisabledInit(){
	drivetrain->ResetEncoder();
}

void Robot::DisabledPeriodic() {
	Scheduler::GetInstance()->Run();
//	gearPickup->ReadPixyData();
//	gearPickup->RunShoveEnc();
//
//	gearPickup->CloseGate();
//	gearPickup->currentGateState = OPEN;
//
//	SmartDashboard::PutNumber("Distance Traveled", drivetrain->GetDistanceTraveled());
//	drivetrain->IgnoreJoystickInput(false);
//
//	oi->rumble(0.0);
//
//	std::printf("Distance Traveled: %f\n", drivetrain->GetDistanceTraveled());
//
//	SmartDashboard::PutNumber("Front Right Encoder", drivetrain->frontRightEncoder->GetValue());
//	SmartDashboard::PutNumber("Back Right Encoder", drivetrain->backRightEncoder->GetValue());
//	SmartDashboard::PutNumber("Front Left Encoder",  drivetrain->frontLeftEncoder->GetValue());
//	SmartDashboard::PutNumber("Back Left Encoder", drivetrain->backLeftEncoder->GetValue());
//
//	SmartDashboard::PutNumber("Left Ultra", gearPickup->LeftUltraDistance());
////	SmartDashboard::PutNumber("Right Ultra", gearPickup->RightUltraDistance());
//	SmartDashboard::PutNumber("Packets Found", gearPickup->GetPacketsFound());

#ifdef DEBUG
//	gearPickup->PrintValules();
	SmartDashboard::PutData(Scheduler::GetInstance());
	SmartDashboard::PutNumber("Left X" , Robot::oi->getLeftJoystick()->GetX());
	SmartDashboard::PutNumber("Left Y" , Robot::oi->getLeftJoystick()->GetY());
	SmartDashboard::PutNumber("Right X" , Robot::oi->getRightJoystick()->GetX());
#endif
}

void Robot::AutonomousInit() {
//	gearPickup->OpenGate();
//	gearPickup->currentGateState = CLOSED;
//
//	turnFile = fopen("/tmp/TurnFile.log", "w");
//
//	alliance = DriverStation::GetInstance().GetAlliance();
//	if(alliance == DriverStation::Alliance::kInvalid)
//	{
//		alliance = SmartDashboard::GetNumber("DB/AutoRedBlue", 0);
//		if(alliance == 0)
//			alliance = 1;
//		if(alliance == 1)
//			alliance = 0;
//	}
//
//
//	if (autonomousCommand.get() != nullptr)
//	{
////		autoPosition = SmartDashboard::GetNumber("DB/AutoPosition", 0);//0 to 2
////		autoMode = SmartDashboard::GetNumber("DB/AutoMode", 0); //0 to 7
////
//		switch(autoMode)
//		{
////		case 0:
////			autonomousCommand.reset(new AutonomousCommand());
////			break;
////		case 1:
////			if(autoPosition == 0 || autoPosition == 2)
////				autonomousCommand.reset(new AutoPlaceGearCrossBaseline_Sides()); //change drive values later
////			else
////				autonomousCommand.reset(new AutoPlaceGearCrossBaseline_Middle());
////			break;
////		case 2:
////			if(autoPosition == 0 || autoPosition == 2)
////				autonomousCommand.reset(new AutoGearSides());
////			else
////				autonomousCommand.reset(new AutoGearMiddle());
////			break;
////		case 3:
////			//place gear, cross baseline, dump balls
////			//assume closest position to boiler
//////			if(alliance == DriverStation::Alliance::kRed && autoPosition == 0)
//////			{
//////				autonomousCommand.reset(new AutoPlaceGearDumpBalls());
//////				break;
//////			}
//////			else if(alliance == DriverStation::Alliance::kBlue && autoPosition == 2)
//////			{
//////				autonomousCommand.reset(new AutoPlaceGearDumpBalls());
//////				break;
//////			}
//////			autonomousCommand.reset(new AutonomousCommand());
////			break;
////			/*
////		case 4:
////			autonomousCommand.reset(new AutoDump());
////			//dump balls then cross baseline
////			break;
////		case 5:
////			//cross baseline and grab balls from hopper
////			//autoposition 0 or 2 (different for each alliance and location)
////			if(autoPosition == 1)
////				autoPosition = 0;
////
////			if(alliance == DriverStation::Alliance::kRed && autoPosition == 2)
////			{
////				autonomousCommand.reset(new AutoHopperRed());
////			}
////			else if(alliance == DriverStation::Alliance::kBlue && autoPosition == 0)
////			{
////				autonomousCommand.reset(new AutoHopperBlue());
////			}
////			break;
////		case 6:
////			//place gear, cross baseline, grab balls from hopper
////
////			//implement pos 1 last
////			break;
////		case 7:
////			//place gear, cross baseline, dump balls
////			//assume closest position to boiler
////			if(alliance == DriverStation::Alliance::kRed && autoPosition == 0)
////				break;
////				//check which autopos is closest
////			else if(alliance == DriverStation::Alliance::kBlue && autoPosition == 2)
////				break;
////				//check which autopos is closest
////			break;
////			*/
//		default:
//			autonomousCommand.reset(new AutonomousCommand());
//			break;
//		}
//	}
//	autonomousCommand->Start();

	autonomousCommand.reset(new AutonomousCommand());
	autonomousCommand->Start();
}

void Robot::AutonomousPeriodic() {
	Scheduler::GetInstance()->Run();
//	gearPickup->ReadPixyData();
//	gearPickup->RunShoveEnc();
//
//	SmartDashboard::PutNumber("Gate State",gearPickup->currentGateState);
//	SmartDashboard::PutNumber("Distance Traveled", drivetrain->GetDistanceTraveled());
//
//
//	drivetrain->targetAngle = SmartDashboard::GetNumber("Target Angle", 0);
//	SmartDashboard::PutNumber("Current Angle", drivetrain->GetYaw());
//	SmartDashboard::PutNumber("yTranslation", gearPickup->yTranslation);
//	SmartDashboard::PutNumber("xTranslation", gearPickup->xTranslation);
//
//	SmartDashboard::PutNumber("Front Right Encoder", drivetrain->frontRightEncoder->GetValue());
//	SmartDashboard::PutNumber("Back Right Encoder", drivetrain->backRightEncoder->GetValue());
//	SmartDashboard::PutNumber("Front Left Encoder",  drivetrain->frontLeftEncoder->GetValue());
//	SmartDashboard::PutNumber("Back Left Encoder", drivetrain->backLeftEncoder->GetValue());
//	SmartDashboard::PutNumber("Distance from Center", (double)gearPickup->DistanceFromCenter());
//	SmartDashboard::PutNumber("Left Ultra", gearPickup->LeftUltraDistance());
////	SmartDashboard::PutNumber("Right Ultra", gearPickup->RightUltraDistance());
////	SmartDashboard::PutNumber("Angle", gearPickup->CalcAngle(gearPickup->LeftUltraDistance(), gearPickup->RightUltraDistance()));
//	SmartDashboard::PutNumber("Packets Found", gearPickup->GetPacketsFound());
//
//#ifdef DEBUG
	gearPickup->PrintValules();
	SmartDashboard::PutData(Scheduler::GetInstance());
	SmartDashboard::PutNumber("Left Joy X" , Robot::oi->getLeftJoystick()->GetX());
	SmartDashboard::PutNumber("Left Joy Y" , Robot::oi->getLeftJoystick()->GetY());
	SmartDashboard::PutNumber("Right Joy X" , Robot::oi->getRightJoystick()->GetX());
//#endif
}

void Robot::TeleopInit() {
	// This makes sure that the autonomous stops running when
	// teleop starts running. If you want the autonomous to
	// continue until interrupted by another command, remove
	// these lines or comment it out.
//	gearPickup->OpenGate();
//	gearPickup->currentGateState = CLOSED;

	if (autonomousCommand.get() != nullptr)
		autonomousCommand->Cancel();

	drivetrain->ResetEncoder();
}

void Robot::TeleopPeriodic() {
//	if(oi->GetButton10() && oi->GetButton9())
//		StopCommands = true;
//	else
//		StopCommands = false;
/*
	double sliderVal = (oi->getLeftJoystick()->GetZ() + 1.0) /0.5;
	RobotMap::cameraServo->Set(sliderVal);
*/
	Scheduler::GetInstance()->Run();

//	gearPickup->ShoverReverse();

//	SmartDashboard::PutNumber("Gate  State", Robot::gearPickup->currentGateState);
//	SmartDashboard::PutNumber("Shove State", gearPickup->ShoverState);
//	SmartDashboard::PutNumber("Shove Angle", gearPickup->GetShoveAngle());
//
//	SmartDashboard::PutString("DB/String 0", std::to_string(distance));
//
//	gearPickup->ReadPixyData();
//	gearPickup->RunShoveEnc();
//	printf("ENCODER VAL: %f\n", gearPickup->GetShoveAngle());
//
//#ifdef DEBUG
//
//	if(Timer::GetMatchTime() >= 90 && Timer::GetMatchTime() <= 91)
//		oi->rumble(0.5);
//
//	SmartDashboard::PutNumber("Current Angle", drivetrain->GetYaw());
//
//	SmartDashboard::PutNumber("yTranslation", gearPickup->yTranslation);
//	SmartDashboard::PutNumber("xTranslation", gearPickup->xTranslation);
	SmartDashboard::PutNumber("Front Right Encoder", drivetrain->frontRightEncoder->GetValue());
	SmartDashboard::PutNumber("Back Right Encoder", drivetrain->backRightEncoder->GetValue());
	SmartDashboard::PutNumber("Front Left Encoder",  drivetrain->frontLeftEncoder->GetValue());
	SmartDashboard::PutNumber("Back Left Encoder", drivetrain->backLeftEncoder->GetValue());
//	SmartDashboard::PutNumber("Distance from Center", (double)gearPickup->DistanceFromCenter());
//	SmartDashboard::PutNumber("Left Ultra", gearPickup->LeftUltraDistance());
////	SmartDashboard::PutNumber("Right Ultra", gearPickup->RightUltraDistance());
////	SmartDashboard::PutNumber("Angle", gearPickup->CalcAngle(gearPickup->LeftUltraDistance(), gearPickup->RightUltraDistance()));
//	SmartDashboard::PutNumber("Packets Found", gearPickup->GetPacketsFound());
//	gearPickup->PrintValules();
	SmartDashboard::PutData(Scheduler::GetInstance());
	SmartDashboard::PutNumber("Left X" , Robot::oi->getLeftJoystick()->GetX());
	SmartDashboard::PutNumber("Left Y" , Robot::oi->getLeftJoystick()->GetY());
	SmartDashboard::PutNumber("Right X" , Robot::oi->getRightJoystick()->GetX());
//	SmartDashboard::PutBoolean("Right Trigger Pressed", Robot::oi->GetRightTriggerPressed());
//#endif

}

void Robot::TestPeriodic() {
	lw->Run();
}


START_ROBOT_CLASS(Robot);

