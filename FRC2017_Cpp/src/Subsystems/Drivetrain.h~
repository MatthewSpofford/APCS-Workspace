// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#ifndef DRIVETRAIN_H
#define DRIVETRAIN_H
#include "Commands/Subsystem.h"
#include "WPILib.h"
#include "PigeonImu.h"

/**
 *
 *
 * @author ExampleAuthor
 */
class Drivetrain: public Subsystem {
public:
	// It's desirable that everything possible is private except
	// for methods that implement subsystem capabilities
	std::shared_ptr<Ultrasonic> ultrasonic1;
	std::shared_ptr<Ultrasonic> ultrasonic2;

public:
	Drivetrain();
	std::shared_ptr<CANTalon> frontRightTurnMotor;
	std::shared_ptr<CANTalon> frontRightMoveMotor;
	std::shared_ptr<AnalogInput> frontRightEncoder;
	std::shared_ptr<CANTalon> frontLeftTurnMotor;
	std::shared_ptr<CANTalon> frontLeftMoveMotor;
	std::shared_ptr<AnalogInput> frontLeftEncoder;
	std::shared_ptr<CANTalon> backRightTurnMotor;
	std::shared_ptr<CANTalon> backRightMoveMotor;
	std::shared_ptr<AnalogInput> backRightEncoder;
	std::shared_ptr<CANTalon> backLeftTurnMotor;
	std::shared_ptr<CANTalon> backLeftMoveMotor;
	std::shared_ptr<AnalogInput> backLeftEncoder;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	std::shared_ptr<Ultrasonic> ultrasonic1;
	std::shared_ptr<Ultrasonic> ultrasonic2;
	std::shared_ptr<PigeonImu> pidgeotto;
public:
	Drivetrain();
	void InitDefaultCommand();
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
	std::shared_ptr<PigeonImu> pidgeotto;
	//Drives the robot based off of the given values, does calculations for each individual motor
	void DriveControl(double forwardMovement, double directionalMovement, double rotationMovement, bool fieldCentric = true, bool noDeadzone = true);
	//Stops robot movement
	void StopDrive();

	//Receive yaw value
	double GetYaw();
	double targetAngle = 0;
	void ResetEncoder();

	void IgnoreJoystickInput(bool);
	bool GetIgnoreInput();
private:

	const double FORWARD_DEADZONE = 0.08;	//Defines the forward deadzone
	const double STRAFE_DEADZONE = 0.009;	//Defines the strafe deadzone
	const double ROTATION_DEADZONE = 0.03; 	//Defines the rotation deadzone

	const int FR_ENCODER_ZERO = 2635; //initial value = 2605
	const int FL_ENCODER_ZERO = 3619;//initial value = 2646
	const int BR_ENCODER_ZERO = 851; //initial value = 2582
	const int BL_ENCODER_ZERO = 2588; //initial value = 3635

	//Defines forward direction of robot
	const int ROBOT_FORWARD_DIRECTION = -1;
	//Defines strafe direction of robot
	const int ROBOT_STRAFE_DIRECTION = -1;
	//defines rotation direction of robot
	const int ROBOT_ROTATION_DIRECTION = -1;

	const int LENGTH = 27.5;
	const int WIDTH = 19.0;

	//Defines direction for each wheel
	const int BACK_RIGHT_ROTATION_DIR = 1;
	const int BACK_RIGHT_MOVEMENT_DIR = 1;

	const int BACK_LEFT_ROTATION_DIR = 1;
	const int BACK_LEFT_MOVEMENT_DIR = 1;

	const int FRONT_RIGHT_ROTATION_DIR = 1;
	const int FRONT_RIGHT_MOVEMENT_DIR = 1;

	const int FRONT_LEFT_ROTATION_DIR = 1;
	const int FRONT_LEFT_MOVEMENT_DIR = 1;

	bool IgnoreInput = false;

	//Moves the individual swerve drive modules at the calculated speed and rotation
	void DriveForwardRight(double speedValue, double rotationValue);
	void DriveForwardLeft(double speedValue, double rotationValue);
	void DriveBackRight(double speedValue, double rotationValue);
	void DriveBackLeft(double speedValue, double rotationValue);

	double ypr[3]; //Stores the yaw, pitch, and roll of robot
};

#endif
