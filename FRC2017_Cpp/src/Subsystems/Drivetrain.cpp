// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "CANTalon.h"

#define  ERROR_SPEED 999
//#define INVERT_ENCODER

#include "Drivetrain.h"
#include "../RobotMap.h"
#include "../Commands/Drive.h"
#include "math.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Drivetrain::Drivetrain() : Subsystem("Drivetrain") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    frontRightTurnMotor = RobotMap::drivetrainfrontRightTurnMotor;
    frontRightMoveMotor = RobotMap::drivetrainfrontRightMoveMotor;
    frontRightEncoder = RobotMap::drivetrainfrontRightEncoder;
    frontLeftTurnMotor = RobotMap::drivetrainfrontLeftTurnMotor;
    frontLeftMoveMotor = RobotMap::drivetrainfrontLeftMoveMotor;
    frontLeftEncoder = RobotMap::drivetrainfrontLeftEncoder;
    backRightTurnMotor = RobotMap::drivetrainbackRightTurnMotor;
    backRightMoveMotor = RobotMap::drivetrainbackRightMoveMotor;
    backRightEncoder = RobotMap::drivetrainbackRightEncoder;
    backLeftTurnMotor = RobotMap::drivetrainbackLeftTurnMotor;
    backLeftMoveMotor = RobotMap::drivetrainbackLeftMoveMotor;
    backLeftEncoder = RobotMap::drivetrainbackLeftEncoder;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

//    ultrasonic1 = RobotMap::drivetrainUltrasonic1;
//    ultrasonic2 = RobotMap::drivetrainUltrasonic2;
    pidgeotto = RobotMap::pidgey;
//    distEncoder = RobotMap::drivetrainDistEncoder;
//
    pidgeotto->SetFusedHeading(0);
    pidgeotto->SetYaw(0);
//
//    ultrasonic1->SetAutomaticMode(true);
//    ultrasonic2->SetAutomaticMode(true);
//
//    distEncoder->SetDistancePerPulse(4 * acos(-1) / DIST_GEAR_RATIO / 20);
//    distEncoder->Reset();

//    //Sets PID Values of all move motors
    backRightTurnMotor->SetControlMode(CANTalon::kPosition);
    backRightTurnMotor->SetSetpoint(0);
    backRightTurnMotor->SetFeedbackDevice(CANTalon::QuadEncoder);
    backRightTurnMotor->ConfigEncoderCodesPerRev(414);
    backRightTurnMotor->ConfigPeakOutputVoltage(12, -12);
    backRightTurnMotor->ConfigNominalOutputVoltage(0, 0);
    backRightTurnMotor->SetAllowableClosedLoopErr(4);
    backRightTurnMotor->SetPID(10, 0 ,0);
    backRightTurnMotor->SetEncPosition(0);

    backLeftTurnMotor->SetControlMode(CANTalon::kPosition);
    backLeftTurnMotor->SetSetpoint(0);
    backLeftTurnMotor->SetFeedbackDevice(CANTalon::QuadEncoder);
    backLeftTurnMotor->ConfigEncoderCodesPerRev(414);
    backLeftTurnMotor->ConfigPeakOutputVoltage(12, -12);
    backLeftTurnMotor->ConfigNominalOutputVoltage(0, 0);
    backLeftTurnMotor->SetAllowableClosedLoopErr(4);
    backLeftTurnMotor->SetPID(10, 0 ,0);
    backLeftTurnMotor->SetEncPosition(0);

    frontRightTurnMotor->SetControlMode(CANTalon::kPosition);
    frontRightTurnMotor->SetSetpoint(0);
    frontRightTurnMotor->SetFeedbackDevice(CANTalon::QuadEncoder);
    frontRightTurnMotor->ConfigEncoderCodesPerRev(414);
    frontRightTurnMotor->ConfigPeakOutputVoltage(12, -12);
    frontRightTurnMotor->ConfigNominalOutputVoltage(0, 0);
    frontRightTurnMotor->SetAllowableClosedLoopErr(4);
    frontRightTurnMotor->SetPID(10, 0 ,0);
    frontRightTurnMotor->SetEncPosition(0);

    frontLeftTurnMotor->SetControlMode(CANTalon::kPosition);
    frontLeftTurnMotor->SetSetpoint(0);
    frontLeftTurnMotor->SetFeedbackDevice(CANTalon::QuadEncoder);
    frontLeftTurnMotor->ConfigEncoderCodesPerRev(414);
    frontLeftTurnMotor->ConfigPeakOutputVoltage(12, -12);
    frontLeftTurnMotor->ConfigNominalOutputVoltage(0, 0);
    frontLeftTurnMotor->SetAllowableClosedLoopErr(4);
    frontLeftTurnMotor->SetPID(10, 0 ,0);
    frontLeftTurnMotor->SetEncPosition(0);

    swerveDrive = new RobotDriveSwerve(	frontLeftMoveMotor,
										frontRightMoveMotor,
										backLeftMoveMotor,
										backRightMoveMotor,

										frontLeftTurnMotor,
										frontRightTurnMotor,
										backLeftTurnMotor,
										backRightTurnMotor,

										WIDTH, LENGTH);

   ResetEncoder();

//   frontLeftTurnMotor->Disable();
//   frontRightTurnMotor->Disable();
//   backRightTurnMotor->Disable();
//   backLeftTurnMotor->Disable();
}

void Drivetrain::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        SetDefaultCommand(new Drive());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}


// Put methods for controlling this subsystem
// here. Call these from Commands.

void Drivetrain::DriveControl(double forwardMovement, double directionalMovement, double rotationMovement, bool fieldCentric, bool noDeadzone)
{
	forwardMovement = forwardMovement * ROBOT_FORWARD_DIRECTION;
	directionalMovement = directionalMovement * ROBOT_STRAFE_DIRECTION;
	rotationMovement = rotationMovement * ROBOT_ROTATION_DIRECTION;

	if(climberCentric)
	{
		double temp = forwardMovement;
		forwardMovement = -directionalMovement;
		directionalMovement = temp;
	}

	if(!noDeadzone)
	{
		//Causes the motor to not turn if the joystick values are too small
		if(forwardMovement <= FORWARD_DEADZONE && forwardMovement >= -FORWARD_DEADZONE)
			forwardMovement = 0;
		if(directionalMovement <= STRAFE_DEADZONE && directionalMovement >= -STRAFE_DEADZONE)
			directionalMovement = 0;
		if(rotationMovement <= ROTATION_DEADZONE && rotationMovement >= -ROTATION_DEADZONE)
			rotationMovement = 0;

		if(forwardMovement < 0)
			forwardMovement = -pow(forwardMovement, 2.0);
		else
			forwardMovement = pow(forwardMovement, 2.0);

		if(directionalMovement < 0)
			directionalMovement = -pow(directionalMovement, 2.0);
		else
			directionalMovement = pow(directionalMovement, 2.0);

		if(rotationMovement < 0)
			rotationMovement = -pow(rotationMovement, 2.0);
		else
			rotationMovement = pow(rotationMovement, 2.0);
	}

	//Stops drivetrain when every value is zero
	if (forwardMovement == 0 && directionalMovement == 0 && rotationMovement == 0)
	{
#ifdef DEBUG
		DriverStation::ReportError("IN DEADZONE");
#endif
	}

	double PI = acos(-1);

	double yaw = GetYaw() * PI / 180;
	if(fieldCentric && climberCentric == false)
	{
		double temp = forwardMovement * cos(yaw) + directionalMovement * sin(yaw);
		directionalMovement = -forwardMovement * sin(yaw) + directionalMovement * cos(yaw);
		forwardMovement = temp;
	}

	double A = directionalMovement - rotationMovement*(LENGTH/R);
	double B = directionalMovement + rotationMovement*(LENGTH/R);
	double C = forwardMovement - rotationMovement*(WIDTH/R);
	double D = forwardMovement + rotationMovement*(WIDTH/R);//makes the wheel calculations easier


	/** I commented out code for changing the angle based on the quadrant that the vector is in. Right now, the angles are returned within
	 * 	a range of - 180 to 180. If we want, we can change that range to be from 0 to 360, but I don't see any benefit as turning counterclockwise can
	 * 	be done without changing the angle range**/
	double wSpeed1 = sqrt(B*B + C*C);
	double wAngle1 = atan2(B,C) * 180/PI;
	//if(B<0) wAngle1+=180;

	double wSpeed2 = sqrt(B*B + D*D);
	double wAngle2 = atan2(B,D) * 180/PI;
	//if(B<0) wAngle2+=180;

	double wSpeed3 = sqrt(A*A + D*D);
	double wAngle3 = atan2(A,D) * 180/PI;
	//if(A<0) wAngle3+=180;

	double wSpeed4 = sqrt(A*A + C*C);
	double wAngle4 = atan2(A,C) * 180/PI;
	//if(A<0) wAngle4 += 180;

	//normalizes speeds so they're within the ranges of -1 to 1
	double maxSpeed = wSpeed1;
	if(wSpeed2 > maxSpeed) maxSpeed = wSpeed2;
	if(wSpeed3 > maxSpeed) maxSpeed = wSpeed3;
	if(wSpeed4 > maxSpeed) maxSpeed = wSpeed4;

	if(maxSpeed > 1)
	{
		wSpeed1/=maxSpeed;
		wSpeed2/=maxSpeed;
		wSpeed3/=maxSpeed;
		wSpeed4/=maxSpeed;
	}

	//Get encoder values
	double encPos1= frontRightTurnMotor->GetEncPosition();
	double encPos2= frontRightTurnMotor->GetEncPosition();
	double encPos3= backLeftTurnMotor->GetEncPosition();
	double encPos4= backRightTurnMotor->GetEncPosition();

#ifdef INVERT_ENCODER
	encPos1 *= -1;
	encPos2 *= -1;
	encPos3 *= -1;
	encPos4 *= -1;
#endif
	// Make the scale of 1 rotation to be from 0 to 1 (1 being 1 rotation) if that makes sense (it can be any whole number, with the number corresponding to how many rotations it has gone through)
	encPos1/=(1988/1.2);
	encPos2/=(1988/1.2);
	encPos3/=(1988/1.2);
	encPos4/=(1988/1.2);
//	fprintf(file, "%f\n", encPos1, encPos2, encPos3, encPos4);
	//Take the mod of that number, so it displays only a number from 0 to 1 (inclusive, exclusive)
	encPos1= fmod(encPos1,1);
	encPos2= fmod(encPos2,1);
	encPos3= fmod(encPos3,1);
	encPos4= fmod(encPos4,1);
//	fprintf(file, "%f\n", encPos1, encPos2, encPos3, encPos4);

	//Normalizes angles so they are within -1 to 1
	wAngle1 = wAngle1 / 360.0;
	wAngle2 = wAngle2 / 360.0;
	wAngle3 = wAngle3 / 360.0;
	wAngle4 = wAngle4 / 360.0;

	if(shouldReverse(wAngle1, encPos1)){
		if(wAngle1 < 0) wAngle1 += 0.5;
		else wAngle1 -= 0.5;
		wSpeed1 *= -1;
	}
 	if(shouldReverse(wAngle2, encPos2)){
		if(wAngle2 < 0) wAngle2 += 0.5;
		else wAngle2 -= 0.5;
		wSpeed2 *= -1;
	}
 	if(shouldReverse(wAngle3, encPos3)){
		if(wAngle3 < 0) wAngle3 += 0.5;
		else wAngle3 -= 0.5;
		wSpeed3 *= -1;
	}
 	if(shouldReverse(wAngle4, encPos4)){
		if(wAngle4 < 0) wAngle4 += 0.5;
		else wAngle4 -= 0.5;
		wSpeed4 *= -1;
	}


	if(wSpeed1 == 0 && wSpeed2 == 0 && wSpeed3 == 0 && wSpeed4 == 0)
	{
		wSpeed1 = ERROR_SPEED;
		wSpeed2 = ERROR_SPEED;
		wSpeed3 = ERROR_SPEED;
		wSpeed4 = ERROR_SPEED;
	}

	DriveForwardRight(wSpeed2, wAngle2);
	DriveForwardLeft(wSpeed1, wAngle1);
	DriveBackLeft(wSpeed4, wAngle4);
	DriveBackRight(wSpeed3, wAngle3);
}

bool Drivetrain::shouldReverse(double wa, double ca){

	//Convert the next wheel angle, which is from -.5 to .5, to 0 to 1
	if (wa < 0) wa += 1;

	//Find the difference between the two (not sure if the conversion from (-0.5 to 0.5) to (0 to 1) above is needed)
		//Difference between the two points. May be anything between -1 to 1, but we are looking for a number between -.5 to .5
	double longDifference = abs(wa - ca);

		//finds shortest distance (0 to 0.5), always positive though (which is what we want)
	double difference = fmin(longDifference, 1-longDifference);

	//If the difference is greater than 1/4, then return true (aka it is easier for it to turn around and go backwards than go forward)
	if (difference > 0.25) return true;
	//Else return false.
	else return false;
}


void Drivetrain::StopDrive()
{
	backLeftMoveMotor->Set(0);
	backRightMoveMotor->Set(0);;
	frontLeftMoveMotor->Set(0);
	frontRightMoveMotor->Set(0);;
}

void Drivetrain::ResetEncoder()
{
	frontLeftTurnMotor->SetEncPosition((int)(((double)frontLeftEncoder->GetValue() - FL_ENCODER_ZERO) / (4000) * 1657));
	frontRightTurnMotor->SetEncPosition((int)(((double)frontRightEncoder->GetValue() - FR_ENCODER_ZERO) / (4000) * 1657));
	backLeftTurnMotor->SetEncPosition((int)(((double)backLeftEncoder->GetValue() - BL_ENCODER_ZERO) / (4000) * 1657));
	backRightTurnMotor->SetEncPosition((int)(((double)backRightEncoder->GetValue() - BR_ENCODER_ZERO) / (4000) * 1657));
}

void Drivetrain::turnWheels(double value)
{
	DriveForwardLeft(0, value);
	DriveBackLeft(0, value);
	DriveBackRight(0, value);
	DriveForwardRight(0, value);
}

/*
 * Sets speed of motor, and then sets PID input to the specified rotation value
 * Then receive calculated PID value and output new turn speed to the turn motor
 * The setpoint value is also changed to counter the encoder from not reseting
 * after reaching zero
 */
void Drivetrain::DriveForwardRight(double speedValue, double rotationValue)
{
	if(speedValue == ERROR_SPEED)
		return;
#ifdef DEBUG
	SmartDashboard::PutNumber("forwardRight Speed", speedValue);
#endif
	rotationValue = rotationValue * FRONT_RIGHT_ROTATION_DIR;
	frontRightMoveMotor->Set(speedValue * FRONT_RIGHT_MOVEMENT_DIR);
	double encPos = frontRightTurnMotor->GetEncPosition();
#ifdef INVERT_ENCODER
	encPos *= -1;
#endif
	encPos /= (1988/1.2);
	double temp = rotationValue;
	temp +=(int)encPos;
//	encPos = encPos - int(encPos);
	encPos = fmod(encPos, 1.0);
	if ((rotationValue - encPos) > 0.5)
	{
		temp -=1;
	}
	else if ((rotationValue - encPos) < -0.5)
	{
		temp += 1;
	}
#ifdef DEBUG
	SmartDashboard::PutNumber("frontRight Setpoint", temp);
#endif
	frontRightTurnMotor->Set(temp);
	frontRightTurnMotor->Enable();
}

void Drivetrain::DriveForwardLeft(double speedValue, double rotationValue)
{
	if(speedValue == ERROR_SPEED)
		return;
#ifdef DEBUG
	SmartDashboard::PutNumber("forwardLeft Speed", speedValue);
#endif
	rotationValue = rotationValue * FRONT_LEFT_ROTATION_DIR;
	frontLeftMoveMotor->Set(speedValue * FRONT_LEFT_MOVEMENT_DIR);
	double encPos = frontLeftTurnMotor->GetEncPosition();
#ifdef INVERT_ENCODER
	encPos *= -1;
#endif
//	encPos = encPos - int(encPos);
	encPos = fmod(encPos, 1.0);
	double temp = rotationValue;
	temp +=(int)encPos;
	encPos= encPos  - int(encPos);
	if ((rotationValue - encPos) > 0.5)
	{
		temp-=1;
	}
	else if ((rotationValue - encPos) < -0.5)
	{
		temp += 1;
	}
#ifdef DEBUG
	SmartDashboard::PutNumber("frontLeft Setpoint", temp);
#endif
	frontLeftTurnMotor->Set(temp);
	frontLeftTurnMotor->Enable();
}

void Drivetrain::DriveBackRight(double speedValue, double rotationValue)
{
	if(speedValue == ERROR_SPEED)
		return;
#ifdef DEBUG
	SmartDashboard::PutNumber("backRight Speed", speedValue);
#endif
	rotationValue = rotationValue * BACK_RIGHT_ROTATION_DIR;
	backRightMoveMotor->Set(speedValue * BACK_RIGHT_MOVEMENT_DIR);
	double encPos = backRightTurnMotor->GetEncPosition();
#ifdef INVERT_ENCODER
	encPos *= -1;
#endif
	encPos /= (1988/1.2);
	double temp = rotationValue;
	temp +=(int)encPos;
//	encPos = encPos - int(encPos);
	encPos = fmod(encPos, 1.0);
	if ((rotationValue - encPos) > 0.5)
	{
		temp-=1;
	}
	else if ((rotationValue - encPos) < -0.5)
	{
		temp += 1;
	}
#ifdef DEBUG
	SmartDashboard::PutNumber("backRight Setpoint", temp);
#endif
	backRightTurnMotor->Set(temp);
	backRightTurnMotor->Enable();
}

void Drivetrain::DriveBackLeft(double speedValue, double rotationValue)
{
	if(speedValue == ERROR_SPEED)
		return;
#ifdef DEBUG
	SmartDashboard::PutNumber("backLeft Speed", speedValue);
#endif
	rotationValue = rotationValue * BACK_LEFT_ROTATION_DIR;
	backLeftMoveMotor->Set(speedValue * BACK_LEFT_MOVEMENT_DIR);

	double encPos = backLeftTurnMotor->GetEncPosition();
#ifdef INVERT_ENCODER
	encPos *= -1;
#endif
	encPos /= (1988/1.2);
	double temp = rotationValue;
	temp +=(int)encPos;
//	encPos = encPos - int(encPos);
	encPos = fmod(encPos, 1.0);
	if ((rotationValue - encPos) > 0.5)
	{
		temp-=1;
	}
	else if ((rotationValue - encPos) < -0.5)
	{
		temp += 1;
	}
#ifdef DEBUG
	SmartDashboard::PutNumber("backLeft Setpoint", temp);
#endif
	backLeftTurnMotor->Set(temp);
	backLeftTurnMotor->Enable();
}

void Drivetrain::IgnoreJoystickInput(bool value)
{
	IgnoreInput = value;
}

bool Drivetrain::GetIgnoreInput()
{
	return IgnoreInput;
}

double Drivetrain::GetYaw()
{
	double temp =  0 - pidgeotto->GetFusedHeading();
	return fmod(temp, 360.0);
}

double Drivetrain::TurnToAngle(double targetAngle)
{
	static FILE *logfile = fopen("/tmp/4048New.log", "w");;
	double currentAngle = -Robot::drivetrain->GetYaw();
	double z = 0;
	if(!(abs(targetAngle - currentAngle) <= ANGLE_MARGIN))
	{
		z = (targetAngle - currentAngle)/900;
		if(z > 0) z += 0.07;
		else z -= 0.07;
			//1. find max speed i.e. 0.1
			//2. divide 90/max speed i.e. 900
			//divide 30 by 900 to get range from 0 to 0.03, then add 0.07 to get range from 0.07 to 0.1
			//- we found the ideal range of speeds to be 0.08 to 0.10
	}
	else
	{
		z = 0;
	}

	if(z >= MAX_AUTO_TURN_SPEED)
		z = MAX_AUTO_TURN_SPEED;

	SmartDashboard::PutNumber("z", z);

	if (logfile) {
		fprintf(logfile, "%f, \n", z);
		fflush(logfile);
	}
	return z;
}

double Drivetrain::GetDistanceTraveled()
{
	return distEncoder->GetDistance();
}

void Drivetrain::ResetDistEnc()
{
	distEncoder->Reset();
}
