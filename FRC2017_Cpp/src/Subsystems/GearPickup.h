#define UNASSIGNED 0
#define SUCCESS 1
#define FAILURE 2
#define RUNNING 3

#define CLOSED 0
#define HALFWAY 1
#define OPEN 2

// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#ifndef GEARPICKUP_H
#define GEARPICKUP_H
#include "../pixy/pixyPacket.h"
#include "Commands/Subsystem.h"
#include "WPILib.h"
#include "../RobotMap.h"
#include "PigeonImu.h"
#include "../pixy/pixyI2C.h"
#include "PIDController.h"

/**
 *
 *
 * @author ExampleAuthor
 */
class GearPickup: public Subsystem {
private:

	// It's desirable that everything possible is private except
	// for methods that implement subsystem capabilities
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	std::shared_ptr<Ultrasonic> ultrasonic1;
	std::shared_ptr<Ultrasonic> ultrasonic2;
	std::shared_ptr<Servo> leftGateServo;
	std::shared_ptr<Servo> rightGateServo;
	std::shared_ptr<Servo> leftPushServo;
	std::shared_ptr<Servo> rightPushServo;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	std::shared_ptr<Counter> pushEncoder;
	std::shared_ptr<Spark> pushMotor;
	std::shared_ptr<DigitalInput> pushLimitSwitch;
public:
	void InitDefaultCommand();
	GearPickup();
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	double xTranslation = 0;
	double yTranslation = 0;
	int badPacketCount = 0;
	int badUltraCount = 0;

	unsigned short int CompletedWallParallel = UNASSIGNED; 	//0 - unassigned, 1 - Worked Correctly, 2 - Failed, 3 - Running
#ifdef DEBUG
	void PrintValules();	//prints packet values
#endif
	void ReadPixyData();	//Reads the pixy data from the camera, and sorts it too the

	void OpenGate();	//Opens servo gate
	void OpenGateHalfway(); //Opens servo halfway
	void CloseGate();	//Closes servo gate
	void Push();		//Pushes gear out
	void UnPush();		//Stops pushing

	bool autoPlaceTriggered = false;
	bool pushTriggered = false;
	bool openTriggered = false;
	bool closeTriggered = false;
	bool dumpTriggered = false;

	Timer OpenTimer;
	const double OPEN_DELAY = 0.25;
	const double PUSH_DELAY = 0.40;
	void StartOpenTimer();
	bool PassedOpenDelay();

	bool InAutoPlacement = false;
	int currentGateState = CLOSED;

	bool IsCorrectlyDistanced(double targetDistance);	//Outputs if correctly distanced from wall
	double LeftUltraDistance();
	double RightUltraDistance();

	double lastLeft;
	void AlignRobot(double targetY);
	void MoveTo(double targetY, bool IsTeleop);
	unsigned short int GetPacketsFound();

	double CalcAngle(double currentLeft, double currentRight);				//Calculates angle of robot from wall
	double DistanceFromCenter();	//Uses the pixy camera to check the distance the robot has to strafe

	bool GetBadPixyData();		//Returns if the pixy data was bad for a long enough time
	bool GetBadUltraData();

	double GetTargetAngle(bool IsTeleop = true);

	void RunShoverLogic();
	void RunShoveEnc();
	void ShoverForward();
	void ShoverReverse();
	void ShoverStop();
	double GetShoveAngle();
	const double SHOVER_BEG_VAL = 84;
	const double SHOVER_SHORT_BEG_VAL = 44;
	const double SHOVER_MID_VAL = 21;
	const double SHOVER_END_VAL = 41;
	bool GetShoveLimit();
	void ResetShoveAngle();
	short int ShoverState = 0;	//0 = Start, 1 = Mid, 2 = End

private:
	PixyI2C *pixy;				//Grabs all of the data from the I2C Bus
	PixyPacket currentPacket1, currentPacket2;	//stores the current packet grabbed from the I2C
	PixyPacket left, right;		//Stores the current values of the targets
	unsigned short int packetsFound = 0;

	const int SKIP_CYCLE = 0;

	const int MAX_BAD_PACKET = 20;
	const int MAX_BAD_ULTRA = 25;

	const double RATIO_UPPER = 2.43;	//Upper value of the height / width ratio
	const double RATIO_LOWER = 1.80;	//Lower value of the height / width ratio
	const double PIXY_AREA_MARGIN = 55;

	const double CAMERA_CENTER_X = 160;
	const double CENTER_DIST_MARGIN = 7.0;//unit is pixels, should be large enough so the robot doesn't keep trying to hit the exact center

	const double ULTRASONIC_DIST_MARGIN = 1;	//Margin for ultrasoniic distance in inches
	const double ANGLE_MARGIN = 1;

	const double DIS_BETWEEN_ULTRAS = 9.0;

	const double LEFT_OPEN = 0.82;
	const double RIGHT_OPEN = 0.26;
	const double LEFT_MID_OPEN = 0.45;
	const double RIGHT_MID_OPEN = 0.62;
	const double LEFT_CLOSE = 0.257;
	const double RIGHT_CLOSE = 0.81;

	const double LEFT_PUSH_OPEN = 0.38;
	const double RIGHT_PUSH_OPEN = 0.475;

	const double LEFT_PUSH_CLOSE = 0.78;
	const double RIGHT_PUSH_CLOSE = 0.15;

	const double Y_TRANS_SCALE = 80;
	const double X_TRANS_SCALE = 100;
	const double ROTATION_SCALE = 2.35;

	const double MAX_Y_TRANSLATE = 0.25;
	const double MIN_Y_TRANSLATE = 0.16;
	const double MAX_X_TRANSLATE = 0.20;
	const double MIN_X_TRANSLATE = 0.10;

	const double MIN_X_DIFFERENCE = 5.0;

	int ShoveEncCount = 0;
	int timeoutVal = 0;
	const int S_M_TIMEOUT = 1.5;
	const int M_E_TIMEOUT = 2.25;
	const int E_S_TIMEOUT = 3.25;
	const int PUSH_ENC_STOP_VAL = 4;

	bool SanityCheck(PixyPacket temp);	//Does a sanity check on a packet
	int GetCenterX();		//Outputs X value between the left and right target
};

#endif
