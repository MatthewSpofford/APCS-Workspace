// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.



#include "GearPickup.h"
#include "PigeonImu.h"
#include "CANTalon.h"
#include <SmartDashboard/SmartDashboard.h>
#include "../Robot.h"
#include "../Commands/ToggleGear.h"
#include "stdio.h"
#include "math.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

GearPickup::GearPickup() : Subsystem("GearPickup") {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    ultrasonic1 = RobotMap::gearPickupultrasonic1;
    ultrasonic2 = RobotMap::gearPickupultrasonic2;
    leftGateServo = RobotMap::gearPickupleftGateServo;
    rightGateServo = RobotMap::gearPickuprightGateServo;
    leftPushServo = RobotMap::gearPickupleftPushServo;
    rightPushServo = RobotMap::gearPickuprightPushServo;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    pushEncoder = RobotMap::gearPickupPushEncoder;
    pushLimitSwitch = RobotMap::gearPickupPushEncLimit;
    pushMotor = RobotMap::gearPickupPushMotor;

	pixy = new PixyI2C();

	lastLeft = LeftUltraDistance();
//	lastRight = RightUltraDistance();

	if(rightGateServo->Get() == RIGHT_CLOSE)
		currentGateState = CLOSED;
	else if(leftGateServo->Get() == RIGHT_MID_OPEN)
		currentGateState = HALFWAY;
	else
		currentGateState = OPEN;

	CompletedWallParallel = UNASSIGNED;
}

static FILE *logfile = 0;

void GearPickup::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

	SetDefaultCommand(new ToggleGear());

	if (logfile == 0) {
		logfile = fopen("/tmp/4048.log", "w");
		fprintf(logfile, "xTranslation,yTranslation,angle,yaw,leftX,leftY,leftHeight,leftWidth,rightX,rightY,rightHeight,rightWidth,DistanceToCenter,LeftUltraDistance,RightUltraDistance");
	}
}


// Put methods for controlling this subsystem
// here. Call these from Commands.

void GearPickup::AlignRobot(double targetY)
{
	static int cyclesSkipped = 0;
	static double maxZ = 0;
	static int count = 0;
	if(cyclesSkipped == SKIP_CYCLE)
	{
		count += 1;
		cyclesSkipped = 0;
		double currentLeft = LeftUltraDistance();
		double currentRight = RightUltraDistance();
		if(abs(currentLeft - lastLeft) >= 6)// && abs(currentRight - lastRight) >= 3)
		{
			currentLeft = lastLeft;
		}
		lastLeft = currentLeft;

		if(CalcAngle(currentLeft, currentRight) > 30 || CalcAngle(currentLeft, currentRight) < -30)
			return;
		else
		{
			yTranslation = abs(currentRight - targetY);

			xTranslation = (double)DistanceFromCenter();

		//	if(abs(xTranslation) <= CENTER_DIST_MARGIN)
		//		xTranslation = 0;
			xTranslation = xTranslation / X_TRANS_SCALE;

			if(abs(yTranslation) <= ULTRASONIC_DIST_MARGIN)
				yTranslation = 0;
			yTranslation = yTranslation / Y_TRANS_SCALE;

			yTranslation *= .15;
			xTranslation *= .25;

			if(GetPacketsFound() < 2)
			{
				xTranslation = 0;
				badPacketCount += 1;
			}
			else
				badPacketCount = 0;

			if(yTranslation < MIN_Y_TRANSLATE)
				yTranslation = MIN_Y_TRANSLATE;
			if(yTranslation > -MIN_Y_TRANSLATE && yTranslation < 0)
				yTranslation = -MIN_Y_TRANSLATE;

			double angle = CalcAngle(currentLeft,currentRight)/(ROTATION_SCALE*180)*0.5;
			if (logfile) {
				fprintf(logfile, "%f,%f,%f,%d,%d,%d,%d,%d,%d,%d,%d,%f,%f,%f\n",
								 -xTranslation, -yTranslation, angle, left.X, left.Y, left.Height, left.Width,
																	  right.X, right.Y, right.Height, right.Width, DistanceFromCenter(),
																	  LeftUltraDistance(),
																	  RightUltraDistance());
				fflush(logfile);
			}

			//CalcAngle(currentLeft,currentRight)/(ROTATION_SCALE*180)*0.35
			//Robot::drivetrain->DriveControl(0, 0, 0.03, false, true);

			SmartDashboard::PutNumber("Target Y", targetY);

			SmartDashboard::PutNumber("yTranslation", yTranslation);
			SmartDashboard::PutNumber("xTranslation", xTranslation);
			SmartDashboard::PutNumber("Max Z", maxZ);
		}
	}
	else
		cyclesSkipped += 1;
}
void GearPickup::MoveTo(double targetY, bool IsTeleop)
{
	double currentLeft = LeftUltraDistance();
	double yTranslation;
	if(abs(currentLeft - lastLeft) >= 6)
	{
		currentLeft = lastLeft;
		yTranslation = abs(currentLeft - targetY);
		badUltraCount = 0;
	}
	else
	{
		yTranslation = 0.0;
		badUltraCount += 1;
	}
	lastLeft = currentLeft;


	double xTranslation = (double)DistanceFromCenter();

	if(xTranslation >= 0)
		xTranslation = fmin((xTranslation / X_TRANS_SCALE) * (MAX_X_TRANSLATE - MIN_X_TRANSLATE) + MIN_X_TRANSLATE, (double)MAX_X_TRANSLATE);
	else
		xTranslation = fmax((xTranslation / X_TRANS_SCALE) * (MAX_X_TRANSLATE - MIN_X_TRANSLATE) + MIN_X_TRANSLATE, (double)-MAX_X_TRANSLATE);

	if(fabs(yTranslation) != 0)
	{
		if(yTranslation >= 0)
			yTranslation = fmin((yTranslation / Y_TRANS_SCALE) * (MAX_Y_TRANSLATE - MIN_Y_TRANSLATE) + MIN_Y_TRANSLATE, (double)MAX_Y_TRANSLATE);
		else
			yTranslation = fmax((yTranslation / Y_TRANS_SCALE) * (MAX_Y_TRANSLATE - MIN_Y_TRANSLATE) + MIN_Y_TRANSLATE, (double)-MAX_Y_TRANSLATE);
	}

	if(GetPacketsFound() < 2)
	{
		if(badPacketCount >= 5)
			xTranslation = 0;
		badPacketCount += 1;
	}
	else
		badPacketCount = 0;

	double angle =  Robot::drivetrain->TurnToAngle(GetTargetAngle(IsTeleop));

	if (logfile) {
		fprintf(logfile, "%f,%f,%f, %f, %d,%d,%d,%d,%d,%d,%d,%d,%f,%f,%f\n",
				 xTranslation, -yTranslation, angle, Robot::drivetrain->GetYaw(), left.X, left.Y, left.Height, left.Width,
																	  right.X, right.Y, right.Height, right.Width, DistanceFromCenter(),
																	  LeftUltraDistance(),
																	  RightUltraDistance());
		fflush(logfile);
	}


	Robot::drivetrain->DriveControl(xTranslation, -yTranslation, angle, false, true);
}

void GearPickup::OpenGateHalfway()
{
	leftGateServo->Set(LEFT_MID_OPEN);
	rightGateServo->Set(RIGHT_MID_OPEN);
	SmartDashboard::PutNumber("Servo Pos", rightGateServo->Get());
}

void GearPickup::OpenGate()
{
	leftGateServo->Set(LEFT_OPEN);
	rightGateServo->Set(RIGHT_OPEN);
	SmartDashboard::PutNumber("Servo Pos", rightGateServo->Get());
}

void GearPickup::CloseGate()
{
	leftGateServo->Set(LEFT_CLOSE);
	rightGateServo->Set(RIGHT_CLOSE);
	SmartDashboard::PutNumber("Servo Pos", rightGateServo->Get());
}

void GearPickup::Push()
{
	leftPushServo->Set(LEFT_PUSH_OPEN);
	rightPushServo->Set(RIGHT_PUSH_OPEN);
}

void GearPickup::UnPush()
{
	rightPushServo->Set(LEFT_PUSH_CLOSE);
	rightPushServo->Set(RIGHT_PUSH_CLOSE);
}

void GearPickup::StartOpenTimer()
{
	OpenTimer.Stop();
	OpenTimer.Reset();
	OpenTimer.Start();
}

bool GearPickup::PassedOpenDelay()
{
	SmartDashboard::PutNumber("OpenTimer",OpenTimer.Get());
	return OpenTimer.Get() >= OPEN_DELAY;
}

bool GearPickup::IsCorrectlyDistanced(double targetDistance)
{
	SmartDashboard::PutNumber("Correct Distance Target", targetDistance);
	if(//abs(LeftUltraDistance() - RightUltraDistance()) <= .75 &&
		LeftUltraDistance() - targetDistance  <= ULTRASONIC_DIST_MARGIN &&
		RightUltraDistance() - targetDistance <= ULTRASONIC_DIST_MARGIN &&
		fabs(DistanceFromCenter()) <=  CENTER_DIST_MARGIN)
	{
		SmartDashboard::PutBoolean("Correct Distance Return", true);
		return true;
	}
	else
		SmartDashboard::PutBoolean("Correct Distance Return", false);
		return false;
}

double GearPickup::LeftUltraDistance()
{
	return ultrasonic1->GetRangeInches();
}

double GearPickup::RightUltraDistance()
{
	return ultrasonic2->GetRangeInches();
}

double GearPickup::CalcAngle(double currentLeft, double currentRight)
{
	double angleDeviation = atan((currentLeft - currentRight) / DIS_BETWEEN_ULTRAS) / acos(-1) * 180;
	//if(abs(angleDeviation) <= ANGLE_MARGIN)
	//	angleDeviation = 0;

	return angleDeviation;
}

double GearPickup::DistanceFromCenter()
{
	return -((right.X + left.X) / 2 - CAMERA_CENTER_X);
}

void GearPickup::ReadPixyData()
{
	int packetCount = 0;
	packetCount = pixy->readPacket();
	if(packetCount >= 2)
	{

		PixyPacket minx = PixyPacket();
		PixyPacket maxx = PixyPacket();
		for (int x = 0; x < packetCount; x++)
		{
			PixyPacket p = pixy->packets[x];
			PixyPacket tempMax = PixyPacket();
			PixyPacket tempMin = PixyPacket();

			if (!SanityCheck(p))
				continue;
			if (p.X < minx.X || minx.isNull())
			{
				tempMin = minx;
				minx = p;
			}
			if (p.X > maxx.X)
			{
				tempMax = maxx;
				maxx = p;
			}

			if(maxx.X - minx.X <= MIN_X_DIFFERENCE)
			{
				if(!tempMax.isNull())
					maxx = tempMax;
				if(!tempMin.isNull())
					minx = tempMin;
			}
		}

		if (minx.isSame(maxx))
		{
			packetsFound = 0;
			return;
		}

		currentPacket1 = minx;
		currentPacket2 = maxx;

//    		if(currentPacket1 == null || currentPacket2 == null){
//    			packetsFound = 0;
//    			return;
//    		}
//
//    		if(currentPacket2.isNull() || currentPacket1.isNull()){
//    			packetsFound = 0;
//    			return;
//    		}
//    		if(!SanityCheck(currentPacket1) && !SanityCheck(currentPacket2)){
//    			packetsFound = 0;
//    			return;
//    		}
//    		else{

		if(currentPacket1.isSame(left) || currentPacket1.isSame(right))
		{
			packetsFound = 0;
			return;
		}
		if(currentPacket2.isSame(left) || currentPacket2.isSame(right))
		{
			packetsFound = 0;
			return;
		}


		if (currentPacket1.isLeftOf(currentPacket2))
		{
			left = currentPacket1;
			right = currentPacket2;
		}
		else
		{
			left = currentPacket2;
			right = currentPacket1;
		}
		packetsFound = 2;
//    		}
	}
	else
	{
		packetsFound = 0;
	}
	static FILE* file = fopen("/tmp/targetData.log", "w");
	fprintf(file, "%d  LEFT: %d, %d, %d, %d  RIGHT: %d, %d, %d, %d\n", packetCount, left.X, left.Y, left.Height, left.Width, right.X, right.Y, right.Height, right.Width);
}

unsigned short int GearPickup::GetPacketsFound()
{
	return packetsFound;
}

bool GearPickup::GetBadPixyData()
{
	if(badPacketCount >= MAX_BAD_PACKET)
	{
		DriverStation::ReportError("BAD PIXY DATA");
		return true;
	}
	else
		return false;
}

bool GearPickup::GetBadUltraData()
{
	if(badUltraCount >= MAX_BAD_ULTRA)
	{
		DriverStation::ReportError("BAD ULTRA DATA");
		return true;
	}
	else
		return false;
}

bool GearPickup::SanityCheck(PixyPacket temp)
{
	//if((RATIO_UPPER >= temp.getRatio()) && (temp.getRatio() >= RATIO_LOWER))
	if(temp.Height * temp.Width >= 55)
		return true;
	else
		return false;
}

#ifdef DEBUG
void GearPickup::PrintValules()
{
	SmartDashboard::PutNumber("Left Object X", left.X);
	SmartDashboard::PutNumber("Left Object Y", left.Y);
	SmartDashboard::PutNumber("Left Object Width", left.Width);
	SmartDashboard::PutNumber("Left Object Height", left.Height);

	SmartDashboard::PutNumber("Right Object X", right.X);
	SmartDashboard::PutNumber("Right Object Y", right.Y);
	SmartDashboard::PutNumber("Right Object Width", right.Width);
	SmartDashboard::PutNumber("Right Object Height", right.Height);
}
#endif

double GearPickup::GetTargetAngle(bool IsTeleop)
{
	/**During teleop, we won't know what target angle the robot should turn to. this depends
	 * on which gear it is trying to line up with. this checks which angle the current angle is closest
	 * to and sets that as the target, assuming that the driver attempts to be close to parallel with the
	 * lift
	 */
	DriverStation::ReportError("getting current angle");
	if(IsTeleop)
	{
		double currentAngle = -Robot::drivetrain->GetYaw();
		if(currentAngle < 0)
		{
			double angle1 = abs(-270 - currentAngle);
			double angle2 = abs(-210 - currentAngle);
			double angle3 = abs(-330 - currentAngle);
			if(angle1 < angle2 && angle1 < angle3) return -270;
			else if(angle2 < angle1 && angle2 < angle3) return -210;
			else if(angle3 < angle1 && angle3 < angle2) return -330;
			else return -1;
		}
		else
		{
			double angle1 = abs(90 - currentAngle);
			double angle2 = abs(150 - currentAngle);
			double angle3 = abs(30 - currentAngle);
			if(angle1 < angle2 && angle1 < angle3) return 90;
			else if(angle2 < angle1 && angle2 < angle3) return 150;
			else if(angle3 < angle1 && angle3 < angle2) return 30;
			else return -1;
		}
	}
	else //this is only for the gear because its presumed that the boiler dumping will
									 //have a specific angle to turn to, not the default 0.
	{
		if(Robot::autoPosition == 0) //&& Robot::gearPickup->CompletedWallParallel == 0 && Robot::gearPickup->currentGateState == OPEN)
			return 150;
		else if(Robot::autoPosition == 1) //&& Robot::gearPickup->CompletedWallParallel == 0 && Robot::gearPickup->currentGateState == OPEN)
			return 90;
		else if(Robot:: autoPosition == 2) //&& Robot::gearPickup->CompletedWallParallel == 0 && Robot::gearPickup->currentGateState == OPEN)
			return 30;
		else
			return 0;
		//calculate angle based on driver station location for autonomous
		//left = -150 deg
		//right = 150 deg
		//middle = 90 deg

		//turning 90 so that gear subsystem faces the lift
	}
}

//void GearPickup::RunPusherLogic()
//{
//	static bool end = false;
//	static bool timeStart = false;
//	static Timer timeout;
//
//	if(Robot::oi->GetPushButton() && !Robot::StopCommands && !end)
//	{
//		if(!timeStart)
//			timeout.Start();
//
//		if(PusherState == 0 && GetPushAngle() <= PUSHER_MID_VAL)
//		{
//			PusherForward();
//			PusherState = 1;
//			end = true;
//		}
//		if(PusherState == 1 && GetPushAngle() <= PUSHER_END_VAL)
//		{
//			PusherForward();
//			PusherState = 2;
//			end = true;
//		}
//		if(PusherState == 2 && !GetPushLimit())
//		{
//			PusherReverse();
//			PusherState = 0;
//			end = true;
//		}
//	}
//	if(end)
//	{
//		timeStart = false;
//		timeout.Stop();
//		timeout.Reset();
//		PusherStop();
//	}
//}

void GearPickup::RunShoveEnc()
{
	if(!pushEncoder->GetStopped())
	{
		int samples = pushEncoder->Get();
//		int dif = abs(samples - lastVal);

		//Takes into account direction, decreases count if going in reverse
//		samples += dif;

//		printf("COUNTER: %0f %5d +%3d\n", period, samples, (samples - lastValue));
//		lastVal = samples;

		//174.9 = Gear Ratio
		ShoveEncCount = -samples / 1;
	}
}

void GearPickup::ResetShoveAngle()
{
	pushEncoder->Reset();
	ShoveEncCount = 0;
}

void GearPickup::ShoverForward()
{
	pushMotor->Set(-1.0);
}

void GearPickup::ShoverStop()
{
	pushMotor->Set(0);
}

void GearPickup::ShoverReverse()
{
	pushMotor->Set(1.0);
}

double GearPickup::GetShoveAngle()
{
	return ShoveEncCount;
}

bool GearPickup::GetShoveLimit()
{
	static int prevPos = 0;
	static int skipCount = 0;
	if(skipCount == 0)
	{
		if(GetShoveAngle() - prevPos <= 0)
			return true;
		prevPos = GetShoveAngle();
		skipCount++;
	}
	else if(skipCount == 10)
	{
		skipCount = 0;
	}
	else
	{
		skipCount++;
	}

	return false;
}
