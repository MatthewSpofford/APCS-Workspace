// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#ifndef DRIVETRAIN_H
#define DRIVETRAIN_H
#include "Commands/Subsystem.h"
#include "WPILib.h"
#include "PigeonImu.h"
#include "RobotMap.h"
#include "../Swerve Drive Project/RobotDriveSwerve.h"

/**
 *
 *
 * @author ExampleAuthor
 */
class Drivetrain: public Subsystem {
public:
	// It's desirable that everything possible is private except
	// for methods that implement subsystem capabilities
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	std::shared_ptr<CANTalon> frontRightTurnMotor;
	std::shared_ptr<CANTalon> frontRightMoveMotor;
	std::shared_ptr<AnalogInput> frontRightEncoder;
	std::shared_ptr<CANTalon> frontLeftTurnMotor;
	std::shared_ptr<CANTalon> frontLeftMoveMotor;
	std::shared_ptr<AnalogInput> frontLeftEncoder;
	std::shared_ptr<CANTalon> backRightTurnMotor;
	std::shared_ptr<CANTalon> backRightMoveMotor;
	std::shared_ptr<AnalogInput> backRightEncoder;
	std::shared_ptr<CANTalon> backLeftTurnMotor;
	std::shared_ptr<CANTalon> backLeftMoveMotor;
	std::shared_ptr<AnalogInput> backLeftEncoder;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	std::shared_ptr<Ultrasonic> ultrasonic1;
	std::shared_ptr<Ultrasonic> ultrasonic2;
	std::shared_ptr<Encoder> distEncoder;

public:

	RobotDriveSwerve* swerveDrive;

	Drivetrain();
	void InitDefaultCommand();
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
	std::shared_ptr<PigeonImu> pidgeotto;
	//Drives the robot based off of the given values, does calculations for each individual motor
	void DriveControl(double forwardMovement, double directionalMovement, double rotationMovement, bool fieldCentric = true, bool noDeadzone = false);
	//Stops robot movement
	void StopDrive();

	bool shouldReverse(double wa, double ca);

	void turnWheels(double value);

	double GetDistanceTraveled();
	void ResetDistEnc();

	//Receive yaw value
	double GetYaw();
	double targetAngle = 0;
	void ResetEncoder();
	const double ANGLE_MARGIN = 3;

	double TurnToAngle(double targetAngle);
	void IgnoreJoystickInput(bool);
	bool GetIgnoreInput();

	bool fieldCentric = true;	//When true, is field centric; when false, is robot centric
	bool climberCentric = false;
private:

	const double DIST_GEAR_RATIO = 6 + 2/3;

	const double FORWARD_DEADZONE = 0.075;	//Defines the forward deadzone
	const double STRAFE_DEADZONE = 0.075;	//Defines the strafe deadzone
	const double ROTATION_DEADZONE = 0.075; 	//Defines the rotation deadzone

//#define REAL_ROBOT

#ifndef REAL_ROBOT
	const int FR_ENCODER_ZERO = 2605; //initial value = 2605
	const int FL_ENCODER_ZERO = 2646; //initial value = 2646
	const int BR_ENCODER_ZERO = 2582; //initial value = 2582
	const int BL_ENCODER_ZERO = 3635; //initial value = 3635
#else
	const int FR_ENCODER_ZERO = 748;
	const int FL_ENCODER_ZERO = 2830;
	const int BR_ENCODER_ZERO = 613;
	const int BL_ENCODER_ZERO = 1765;
#endif

	//Defines forward direction of robot
	const int ROBOT_FORWARD_DIRECTION = 1;
	//Defines strafe direction of robot
	const int ROBOT_STRAFE_DIRECTION = 1;
	//defines rotation direction of robot
	const int ROBOT_ROTATION_DIRECTION = 1;

	const double WIDTH = 27.5;
	const double LENGTH = 19;
	//length and width of chassis, since we're using the center as a reference point
	const double R = sqrt((LENGTH*LENGTH) + (WIDTH*WIDTH)) / 2;

	//Defines direction for each wheel
	const int BACK_RIGHT_ROTATION_DIR = 1;
	const int BACK_RIGHT_MOVEMENT_DIR = 1;

	const int BACK_LEFT_ROTATION_DIR = 1;
	const int BACK_LEFT_MOVEMENT_DIR = 1;

	const int FRONT_RIGHT_ROTATION_DIR = 1;
	const int FRONT_RIGHT_MOVEMENT_DIR = 1;

	const int FRONT_LEFT_ROTATION_DIR = 1;
	const int FRONT_LEFT_MOVEMENT_DIR = 1;

	const double MAX_AUTO_TURN_SPEED = .22;

	bool IgnoreInput = false;

	//Moves the individual swerve drive modules at the calculated speed and rotation
	void DriveForwardRight(double speedValue, double rotationValue);
	void DriveForwardLeft(double speedValue, double rotationValue);
	void DriveBackRight(double speedValue, double rotationValue);
	void DriveBackLeft(double speedValue, double rotationValue);


	double ypr[3]; //Stores the yaw, pitch, and roll of robot

};

#endif
