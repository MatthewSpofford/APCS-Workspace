#define UNASSIGNED 0
#define SUCCESS 1
#define FAILURE 2
#define RUNNING 3

#define CLOSED 0
#define HALFWAY 1
#define OPEN 2

// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#ifndef GEARPICKUP_H
#define GEARPICKUP_H
#include "../pixy/pixyPacket.h"
#include "Commands/Subsystem.h"
#include "WPILib.h"
#include "../RobotMap.h"
#include "PigeonImu.h"
#include "../pixy/pixyI2C.h"
#include "PIDController.h"

/**
 *
 *
 * @author ExampleAuthor
 */
class GearPickup: public Subsystem {
private:

	// It's desirable that everything possible is private except
	// for methods that implement subsystem capabilities
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	std::shared_ptr<Ultrasonic> ultrasonic1;
	std::shared_ptr<Ultrasonic> ultrasonic2;
	std::shared_ptr<Servo> leftGateServo;
	std::shared_ptr<Servo> rightGateServo;
	std::shared_ptr<Servo> leftPushServo;
	std::shared_ptr<Servo> rightPushServo;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
public:
	void InitDefaultCommand();
	GearPickup();
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	const double CENTER_MARGIN = 2;		//Margin for target distance to center of screen
	const double MIN_DIST_TO_WALL = 50.8; //2 inches in millimeters
	const double ROT_SPEED = 0.15;
	const double FORWARD_SPEED = 0.2;
	const double STRAFE_SPEED = 0.1;

	unsigned short int CompletedWallParallel = UNASSIGNED; 	//0 - unassigned, 1 - Worked Correctly, 2 - Failed

#ifdef DEBUG
	void PrintValules();	//prints packet values
#endif
	void ReadPixyData();	//Reads the pixy data from the camera, and sorts it too the

	void OpenGate();	//Opens servo gate
	void OpenGateHalfway(); //Opens servo halfway
	void CloseGate();	//Closes servo gate
	void Push();		//Pushes gear out
	void UnPush();		//Stops pushing

	Timer OpenTimer;
	const double OPEN_DELAY = 0.25;
	const double PUSH_DELAY = 0.40;
	void StartOpenTimer();
	bool PassedOpenDelay();

	bool InAutoPlacement = false;
	int currentGateState = CLOSED;

	bool IsCorrectlyDistanced(double targetDistance);	//Outputs if correctly distanced from wall
	double LeftUltraDistance();
	double RightUltraDistance();

	double lastLeft;
	double lastRight;
  
	const double ALIGN_PHASE_1_DIS = 14;
	const double ALIGN_PHASE_2_DIS = 3.5;
	void AlignRobot(double targetY);
	void MoveTo(double targetY);
	unsigned short int GetPacketsFound();

	double CalcAngle(double currentLeft, double currentRight);				//Calculates angle of robot from wall
	double DistanceFromCenter();	//Uses the pixy camera to check the distance the robot has to strafe

	bool GetBadPixyData();		//Returns if the pixy data was bad for a long enough time

private:
	PixyI2C *pixy;				//Grabs all of the data from the I2C Bus
	PixyPacket currentPacket1, currentPacket2;	//stores the current packet grabbed from the I2C
	PixyPacket left, right;		//Stores the current values of the targets
	unsigned short int packetsFound = 0;


	/*PIDController* yTransControl;
	const double YP = 1;
	const double YI = 0;
	const double YD = 0;
	PIDController* xTransControl;
	const double XP = 1;
	const double XI = 0;
	const double XD = 0;
	PIDController*  rotatControl;
	const double RP = 1;
	const double RI = 0;
	const double RD = 0;*/
  
	const int SKIP_CYCLE = 0;

	int badPacketCount = 0;
	const int MAX_BAD_PACKET = 25;

	const double RATIO_UPPER = 2.43;	//Upper value of the height / width ratio
	const double RATIO_LOWER = 1.80;	//Lower value of the height / width ratio

	const int SKIP_CYCLE = 1;

	const double ULTRASONIC_DIST_MARGIN = 1;	//Margin for ultrasoniic distance in inches
	const double ANGLE_MARGIN = 1;
	const double CENTER_DIST_MARGIN = 13.0;//unit is pixels, should be large enough so the robot doesn't keep trying to hit the exact center

	const double Y_TRANS_SCALE = 14;
	const double X_TRANS_SCALE = 135;
	const double ROTATION_SCALE = 2.35;
	const double DIS_BETWEEN_ULTRAS = 9.0;

	const double GATE_OPEN_ANGLE = 90.0;
	const double GATE_HALF_ANGLE = 45.0;
	const double GATE_CLOSE_ANGLE = 0.0;
	const double PUSH_OPEN_ANGLE = 45.0;
	const double PUSH_CLOSE_ANGLE = 0.0;
	const double MIN_SPEED = 0.10;
	const double MIN_Y_TRANSLATE = 0.05;

	double count = 0; //number of times alignment has not run
	bool SanityCheck(PixyPacket temp);	//Does a sanity check on a packet
	int GetCenterX();		//Outputs X value between the left and right targets
};

#endif
