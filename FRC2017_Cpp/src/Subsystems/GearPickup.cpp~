// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.



#include "GearPickup.h"
#include "PigeonImu.h"
#include "CANTalon.h"
#include <SmartDashboard/SmartDashboard.h>
#include "../Robot.h"
#include "stdio.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

GearPickup::GearPickup() : Subsystem("GearPickup") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    ultrasonic1 = RobotMap::gearPickupultrasonic1;
    ultrasonic2 = RobotMap::gearPickupultrasonic2;
    leftGateServo = RobotMap::gearPickupleftGateServo;
    rightGateServo = RobotMap::gearPickuprightGateServo;
    leftPushServo = RobotMap::gearPickupleftPushServo;
    rightPushServo = RobotMap::gearPickuprightPushServo;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    //yTransControl = new PIDController(YP, YI, YD, &ultrasonic1, frc::PIDOutput);
	pixy = new PixyI2C();

	lastLeft = LeftUltraDistance();
	lastRight = RightUltraDistance();

	if(rightGateServo->Get() == RIGHT_CLOSE)
		currentGateState = CLOSED;
	else if(leftGateServo->Get() == RIGHT_MID_OPEN)
		currentGateState = HALFWAY;
	else
		currentGateState = OPEN;
}

static FILE *logfile = 0;

void GearPickup::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

	if (logfile == 0) {
		logfile = fopen("/tmp/4048.log", "w");
		fprintf(logfile, "xTranslation,yTranslation,angle,leftX,leftY,leftHeight,leftWidth,rightX,rightY,rightHeight,rightWidth,DistanceToCenter,LeftUltraDistance,RightUltraDistance");
	}
}


// Put methods for controlling this subsystem
// here. Call these from Commands.

void GearPickup::AlignRobot(double targetY)
{
	static int cyclesSkipped = 0;
	static double maxZ = 0;

	static int count = 0;
	if(cyclesSkipped == SKIP_CYCLE)
	{
		count += 1;
		cyclesSkipped = 0;
		double currentLeft = LeftUltraDistance();
		double currentRight = RightUltraDistance();
		if(abs(currentLeft - lastLeft) >= 6 && abs(currentRight - lastRight) >= 3)
		{
			currentLeft = lastLeft;
			currentRight = lastRight;
		}
		lastLeft = currentLeft;
		lastRight = currentRight;

		if(CalcAngle(currentLeft, currentRight) > 30 || CalcAngle(currentLeft, currentRight) < -30)
			return;
		else
		{
			double yTranslation;

			yTranslation = abs(currentRight - targetY);

			double xTranslation = (double)DistanceFromCenter();

		//	if(abs(xTranslation) <= CENTER_DIST_MARGIN)
		//		xTranslation = 0;
			xTranslation = xTranslation / X_TRANS_SCALE;

			if(abs(yTranslation) <= ULTRASONIC_DIST_MARGIN)
				yTranslation = 0;
			yTranslation = yTranslation / Y_TRANS_SCALE;

			yTranslation *= .15;
			xTranslation *= .25;

			if(GetPacketsFound() < 2)
			{
				xTranslation = 0;
				badPacketCount += 1;
			}
			else
				badPacketCount = 0;

			if(yTranslation < MIN_Y_TRANSLATE)
				yTranslation = MIN_Y_TRANSLATE;
			if(yTranslation > -MIN_Y_TRANSLATE && yTranslation < 0)
				yTranslation = -MIN_Y_TRANSLATE;

			double angle = CalcAngle(currentLeft,currentRight)/(ROTATION_SCALE*180)*0.5;
			if (logfile) {
				fprintf(logfile, "%f,%f,%f,%d,%d,%d,%d,%d,%d,%d,%d,%f,%f,%f\n",
								 -xTranslation, -yTranslation, angle, left.X, left.Y, left.Height, left.Width,
																	  right.X, right.Y, right.Height, right.Width, DistanceFromCenter(),
																	  LeftUltraDistance(),
																	  RightUltraDistance());
				fflush(logfile);
			}

			//CalcAngle(currentLeft,currentRight)/(ROTATION_SCALE*180)*0.35
			//Robot::drivetrain->DriveControl(0, 0, 0.03, false, true);

			SmartDashboard::PutNumber("Target Y", targetY);
			SmartDashboard::PutNumber("Minimum Speed", MIN_SPEED);

			SmartDashboard::PutNumber("yTranslation", yTranslation);
			SmartDashboard::PutNumber("xTranslation", xTranslation);
			SmartDashboard::PutNumber("Max Z", maxZ);
		}
	}
	else
		cyclesSkipped += 1;
}
void GearPickup::MoveTo(double targetY)
{
	double currentLeft = LeftUltraDistance();
	double currentRight = RightUltraDistance();
	if(abs(currentLeft - lastLeft) >= 6 && abs(currentRight - lastRight) >= 3)
	{
		currentLeft = lastLeft;
		currentRight = lastRight;
	}
	lastLeft = currentLeft;
	lastRight = currentRight;

	if(CalcAngle(currentLeft, currentRight) > 30 || CalcAngle(currentLeft, currentRight) < -30)
		return;
	else
	{
		double yTranslation;

		yTranslation = abs(currentRight - targetY);

		double xTranslation = (double)DistanceFromCenter();

	//	if(abs(xTranslation) <= CENTER_DIST_MARGIN)
	//		xTranslation = 0;
		xTranslation = xTranslation / X_TRANS_SCALE;

		if(abs(yTranslation) <= ULTRASONIC_DIST_MARGIN)
			yTranslation = 0;
		yTranslation = yTranslation / Y_TRANS_SCALE;

		yTranslation *= .15;
		xTranslation *= .25;

		if(GetPacketsFound() < 2)
		{
			xTranslation = 0;
			badPacketCount += 1;
		}
		else
			badPacketCount = 0;

		if(yTranslation < MIN_Y_TRANSLATE)
			yTranslation = MIN_Y_TRANSLATE;
		if(yTranslation > -MIN_Y_TRANSLATE && yTranslation < 0)
			yTranslation = -MIN_Y_TRANSLATE;

		SmartDashboard::PutNumber("yTranslation", yTranslation);
		SmartDashboard::PutNumber("xTranslation", xTranslation);
		Robot::drivetrain->DriveControl(xTranslation, yTranslation, 0, false, true);
	}
	else
		cyclesSkipped += 1;
}

void GearPickup::OpenGateHalfway()
{
	leftGateServo->Set(LEFT_MID_OPEN);
	rightGateServo->Set(RIGHT_MID_OPEN);
	SmartDashboard::PutNumber("Servo Pos", rightGateServo->Get());
}
void GearPickup::OpenGate()
{
	leftGateServo->Set(LEFT_OPEN);
	rightGateServo->Set(RIGHT_OPEN);
	SmartDashboard::PutNumber("Servo Pos", rightGateServo->Get());
}

void GearPickup::CloseGate()
{
	leftGateServo->Set(LEFT_CLOSE);
	rightGateServo->Set(RIGHT_CLOSE);
	SmartDashboard::PutNumber("Servo Pos", rightGateServo->Get());
}

void GearPickup::Push()
{
	leftPushServo->Set(LEFT_PUSH_OPEN);
	rightPushServo->Set(RIGHT_PUSH_OPEN);
}

void GearPickup::UnPush()
{
	rightPushServo->Set(LEFT_PUSH_CLOSE);
	rightPushServo->Set(RIGHT_PUSH_CLOSE);
}

void GearPickup::StartOpenTimer()
{
	OpenTimer.Stop();
	OpenTimer.Reset();
	OpenTimer.Start();
}

bool GearPickup::PassedOpenDelay()
{
	return OpenTimer.Get() > OPEN_DELAY;
}

bool GearPickup::IsCorrectlyDistanced(double targetDistance)
{
	SmartDashboard::PutNumber("Correct Distance Target", targetDistance);

	if(//abs(LeftUltraDistance() - RightUltraDistance()) <= .75 &&
		LeftUltraDistance() - targetDistance <= ULTRASONIC_DIST_MARGIN &&
		RightUltraDistance() - targetDistance<= ULTRASONIC_DIST_MARGIN)// &&
		//abs(DistanceFromCenter()) <=  CENTER_DIST_MARGIN)
	{
		SmartDashboard::PutBoolean("Correct Distance Return", true);
		return true;
	}
	else
		SmartDashboard::PutBoolean("Correct Distance Return", false);
		return false;
}

double GearPickup::LeftUltraDistance()
{
	return ultrasonic1->GetRangeInches();
}

double GearPickup::RightUltraDistance()
{
	return ultrasonic2->GetRangeInches();
}

double GearPickup::CalcAngle(double currentLeft, double currentRight)
{
	double angleDeviation = atan((currentLeft - currentRight) / DIS_BETWEEN_ULTRAS) / acos(-1) * 180;

	//if(abs(angleDeviation) <= ANGLE_MARGIN)
	//	angleDeviation = 0;

	return angleDeviation;
}

double GearPickup::DistanceFromCenter()
{
	return -((right.X + left.X) / 2 - CAMERA_CENTER_X);
}

void GearPickup::ReadPixyData()
{
	if(pixy->readPacket(1))
	{
		currentPacket1 = pixy->packets[0];
		currentPacket2 = pixy->packets[1];
#ifdef DEBUG
		currentPacket1.Print(" 1");
		currentPacket2.Print(" 2");
#endif

		if(currentPacket2.isNull() || currentPacket1.isNull())
		{
			packetsFound = 0;
			return;
		}

		if(!SanityCheck(currentPacket1) && !SanityCheck(currentPacket2))
		{
			packetsFound = 0;
			return;
		}
		else
		{
			if(!currentPacket1.isSame(currentPacket2) || currentPacket2.isSame(currentPacket1))
			{
				if(currentPacket1.isLeftOf(currentPacket2))
				{
					left = currentPacket1;
					right = currentPacket2;
				}
				else
				{
					left = currentPacket2;
					right = currentPacket1;
				}
#ifdef DEBUG
				left.Print(" Left");
				right.Print(" Right");
				packetsFound = 2;
#endif
			}
			else
			{
				packetsFound = 1;
			}
		}
	}
	else
		packetsFound = 0;
}

unsigned short int GearPickup::GetPacketsFound()
{
	return packetsFound;
}

bool GearPickup::GetBadPixyData()
{
	if(badPacketCount >= MAX_BAD_PACKET)
		return true;
	else
		return false;
}

bool GearPickup::SanityCheck(PixyPacket temp)
{
	if((RATIO_UPPER >= temp.getRatio()) && (temp.getRatio() >= RATIO_LOWER))
		return true;
	else
		return false;
}

#ifdef DEBUG
void GearPickup::PrintValules()
{
	SmartDashboard::PutNumber("Left Object X", left.X);
	SmartDashboard::PutNumber("Left Object Y", left.Y);
	SmartDashboard::PutNumber("Left Object Width", left.Width);
	SmartDashboard::PutNumber("Left Object Height", left.Height);

	SmartDashboard::PutNumber("Right Object X", right.X);
	SmartDashboard::PutNumber("Right Object Y", right.Y);
	SmartDashboard::PutNumber("Right Object Width", right.Width);
	SmartDashboard::PutNumber("Right Object Height", right.Height);
}
#endif
