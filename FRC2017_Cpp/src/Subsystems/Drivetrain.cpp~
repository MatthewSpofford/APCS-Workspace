// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "CANTalon.h"


#include "Drivetrain.h"
#include "../RobotMap.h"
#include "../Commands/Drive.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Drivetrain::Drivetrain() : Subsystem("Drivetrain") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    frontRightTurnMotor = RobotMap::drivetrainfrontRightTurnMotor;
    frontRightMoveMotor = RobotMap::drivetrainfrontRightMoveMotor;
    frontRightEncoder = RobotMap::drivetrainfrontRightEncoder;
    frontLeftTurnMotor = RobotMap::drivetrainfrontLeftTurnMotor;
    frontLeftMoveMotor = RobotMap::drivetrainfrontLeftMoveMotor;
    frontLeftEncoder = RobotMap::drivetrainfrontLeftEncoder;
    backRightTurnMotor = RobotMap::drivetrainbackRightTurnMotor;
    backRightMoveMotor = RobotMap::drivetrainbackRightMoveMotor;
    backRightEncoder = RobotMap::drivetrainbackRightEncoder;
    backLeftTurnMotor = RobotMap::drivetrainbackLeftTurnMotor;
    backLeftMoveMotor = RobotMap::drivetrainbackLeftMoveMotor;
    backLeftEncoder = RobotMap::drivetrainbackLeftEncoder;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    ultrasonic1 = RobotMap::drivetrainUltrasonic1;
    ultrasonic2 = RobotMap::drivetrainUltrasonic2;
  //  pidgeotto = RobotMap::pidgey;

    //pidgeotto->SetFusedHeading(0);
    //pidgeotto->SetYaw(0);

    ultrasonic1->SetAutomaticMode(true);
    ultrasonic2->SetAutomaticMode(true);

    //Sets PID Values of all move motors
    backRightTurnMotor->SetPID(10, 0 ,0);
    backRightTurnMotor->SetControlMode(CANTalon::kPosition);
    backRightTurnMotor->SetSetpoint(0);
    backRightTurnMotor->SetFeedbackDevice(CANTalon::QuadEncoder);
    backRightTurnMotor->ConfigEncoderCodesPerRev(414);
    backRightTurnMotor->ConfigPeakOutputVoltage(12, -12);
    backRightTurnMotor->ConfigNominalOutputVoltage(0, 0);
    backRightTurnMotor->SetAllowableClosedLoopErr(4);
    backRightTurnMotor->SetEncPosition(0);

    backLeftTurnMotor->SetPID(10, 0 ,0);
    backLeftTurnMotor->SetControlMode(CANTalon::kPosition);
    backLeftTurnMotor->SetSetpoint(0);
    backLeftTurnMotor->SetFeedbackDevice(CANTalon::QuadEncoder);
    backLeftTurnMotor->ConfigEncoderCodesPerRev(414);
    backLeftTurnMotor->ConfigPeakOutputVoltage(12, -12);
    backLeftTurnMotor->ConfigNominalOutputVoltage(0, 0);
    backLeftTurnMotor->SetAllowableClosedLoopErr(4);
    backLeftTurnMotor->SetEncPosition(0);

    frontRightTurnMotor->SetPID(10, 0 ,0);
    frontRightTurnMotor->SetControlMode(CANTalon::kPosition);
    frontRightTurnMotor->SetSetpoint(0);
    frontRightTurnMotor->SetFeedbackDevice(CANTalon::QuadEncoder);
    frontRightTurnMotor->ConfigEncoderCodesPerRev(414);
    frontRightTurnMotor->ConfigPeakOutputVoltage(12, -12);
    frontRightTurnMotor->ConfigNominalOutputVoltage(0, 0);
    frontRightTurnMotor->SetAllowableClosedLoopErr(4);
    frontRightTurnMotor->SetEncPosition(0);

    frontLeftTurnMotor->SetPID(10, 0 ,0);
    frontLeftTurnMotor->SetControlMode(CANTalon::kPosition);
    frontLeftTurnMotor->SetSetpoint(0);
    frontLeftTurnMotor->SetFeedbackDevice(CANTalon::QuadEncoder);
    frontLeftTurnMotor->ConfigEncoderCodesPerRev(414);
    frontLeftTurnMotor->ConfigPeakOutputVoltage(12, -12);
    frontLeftTurnMotor->ConfigNominalOutputVoltage(0, 0);
    frontLeftTurnMotor->SetAllowableClosedLoopErr(4);
    frontLeftTurnMotor->SetEncPosition(0);

   //ResetEncoder();



}

void Drivetrain::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        SetDefaultCommand(new Drive());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}


// Put methods for controlling this subsystem
// here. Call these from Commands.

void Drivetrain::DriveControl(double forwardMovement, double directionalMovement, double rotationMovement, bool fieldCentric, bool noDeadzone)
{
	forwardMovement = forwardMovement * ROBOT_FORWARD_DIRECTION;
	directionalMovement = directionalMovement * ROBOT_STRAFE_DIRECTION;
	rotationMovement = rotationMovement * ROBOT_ROTATION_DIRECTION;

	if(!noDeadzone)
	{
		//Causes the motor to not turn if the joystick values are too small
		if(forwardMovement <= FORWARD_DEADZONE && forwardMovement >= -FORWARD_DEADZONE)
			forwardMovement = 0;
		if(directionalMovement <= STRAFE_DEADZONE && directionalMovement >= -STRAFE_DEADZONE)
			directionalMovement = 0;
		if(rotationMovement <= ROTATION_DEADZONE && rotationMovement >= -ROTATION_DEADZONE)
			rotationMovement = 0;
	}

	//Stops drivetrain when every value is zero
	if (forwardMovement == 0 && directionalMovement == 0 && rotationMovement == 0)
	{
#ifdef DEBUG
		DriverStation::ReportError("IN DEADZONE");
#endif
		StopDrive();
		return;
	}

	double PI = acos(-1);

	/*
	double yaw = GetYaw() * PI / 180;

	if(fieldCentric)
	{
		double temp = forwardMovement * cos(yaw) * directionalMovement * sin(yaw);
		directionalMovement = -forwardMovement * sin(yaw) + directionalMovement * cos(yaw);
		forwardMovement = temp;
	}
	*/

	//all inputs are in the range of -1 to 1
    double rotation = rotationMovement;
    double joystickX = forwardMovement;
    double joystickY = directionalMovement;

    //length and width of chassis, since we're using the center as a reference point
    const int R = sqrt((LENGTH*LENGTH) + (WIDTH*WIDTH))/2;

    double A = joystickX - rotation*LENGTH/R;
	double B = joystickX + rotation*LENGTH/R;
	double C = joystickY - rotation*WIDTH/R;
	double D = joystickY + rotation*WIDTH/R;//makes the wheel calculations easier


    /** I commented out code for changing the angle based on the quadrant that the vector is in. Right now, the angles are returned within
     * 	a range of - 180 to 180. If we want, we can change that range to be from 0 to 360, but I don't see any benefit as turning counterclockwise can
     * 	be done without changing the angle range**/
	double wSpeed1 = sqrt(B*B + C*C);
	double wAngle1 = atan2(C,B) * 180/PI;
	//if(B<0) wAngle1+=180;

	double wSpeed2 = sqrt(B*B + D*D);
	double wAngle2 = atan2(D,B) * 180/PI;
	//if(B<0) wAngle2+=180;

	double wSpeed3 = sqrt(A*A + D*D);
	double wAngle3 = atan2(D,A) * 180/PI;
	//if(A<0) wAngle3+=180;

	double wSpeed4 = sqrt(A*A + C*C);
	double wAngle4 = atan2(C,A) * 180/PI;
	//if(A<0) wAngle4 += 180;

	//normalizes speeds so they're within the ranges of -1 to 1
	double maxSpeed = wSpeed1;
	if(wSpeed2 > maxSpeed) maxSpeed = wSpeed2;
	if(wSpeed3 > maxSpeed) maxSpeed = wSpeed3;
	if(wSpeed4 > maxSpeed) maxSpeed = wSpeed4;

	if(maxSpeed > 1)
	{
        wSpeed1/=maxSpeed;
        wSpeed2/=maxSpeed;
        wSpeed3/=maxSpeed;
        wSpeed4/=maxSpeed;
    }

	//Normalizes angles so they are within -1 to 1
	wAngle1 = wAngle1 / 360.0;
	wAngle2 = wAngle2 / 360.0;
	wAngle3 = wAngle3 / 360.0;
	wAngle4 = wAngle4 / 360.0;

	if(!fieldCentric)
	{

	}

	DriveForwardRight(wSpeed4, wAngle4);
	DriveForwardLeft(wSpeed1, wAngle1);
	DriveBackLeft(wSpeed2, wAngle2);
	DriveBackRight(wSpeed3, wAngle3);
}

void Drivetrain::StopDrive()
{
	backLeftMoveMotor->Set(0);
	backRightMoveMotor->Set(0);;
	frontLeftMoveMotor->Set(0);
	frontRightMoveMotor->Set(0);;
}

void Drivetrain::ResetEncoder()
{
	frontLeftTurnMotor->SetEncPosition((int)(((double)frontLeftEncoder->GetValue() - FL_ENCODER_ZERO) / (4000) * 1657));
	frontRightTurnMotor->SetEncPosition((int)(((double)frontRightEncoder->GetValue() - FR_ENCODER_ZERO) / (4000) * 1657));
	backLeftTurnMotor->SetEncPosition((int)(((double)backLeftEncoder->GetValue() - BL_ENCODER_ZERO) / (4000) * 1657));
	backRightTurnMotor->SetEncPosition((int)(((double)backRightEncoder->GetValue() - BR_ENCODER_ZERO) / (4000) * 1657));


}

/*
 * Sets speed of motor, and then sets PID input to the specified rotation value
 * Then receive calculated PID value and output new turn speed to the turn motor
 * The setpoint value is also changed to counter the encoder from not reseting
 * after reaching zero
 */
void Drivetrain::DriveForwardRight(double speedValue, double rotationValue)
{
#ifdef DEBUG
	SmartDashboard::PutNumber("forwardRight Speed", speedValue);
#endif
	rotationValue = rotationValue * FRONT_RIGHT_ROTATION_DIR;
	frontRightMoveMotor->Set(speedValue * FRONT_RIGHT_MOVEMENT_DIR);
	double encPos = frontRightTurnMotor->GetEncPosition();
	encPos /= 1657;
	double temp = rotationValue;
	temp +=(int)encPos;
	encPos= encPos  - int(encPos);
	if ((rotationValue - encPos) > 0.5)
	{
		temp-=1;
	}
	else if ((rotationValue - encPos) < -0.5)
	{
		temp += 1;
	}
#ifdef DEBUG
	SmartDashboard::PutNumber("frontRight Setpoint", temp);
#endif
	frontRightTurnMotor->SetSetpoint(temp);
	frontRightTurnMotor->Enable();
}

void Drivetrain::DriveForwardLeft(double speedValue, double rotationValue)
{
#ifdef DEBUG
	SmartDashboard::PutNumber("forwardLeft Speed", speedValue);
#endif
	rotationValue = rotationValue * FRONT_LEFT_ROTATION_DIR;
	frontLeftMoveMotor->Set(speedValue * FRONT_LEFT_MOVEMENT_DIR);
	double encPos = frontLeftTurnMotor->GetEncPosition();
	encPos /= 1657;
	double temp = rotationValue;
	temp +=(int)encPos;
	encPos= encPos  - int(encPos);
	if ((rotationValue - encPos) > 0.5)
	{
		temp-=1;
	}
	else if ((rotationValue - encPos) < -0.5)
	{
		temp += 1;
	}
#ifdef DEBUG
	SmartDashboard::PutNumber("frontLeft Setpoint", temp);
#endif
	frontLeftTurnMotor->SetSetpoint(temp);
	frontLeftTurnMotor->Enable();
}

void Drivetrain::DriveBackRight(double speedValue, double rotationValue)
{
#ifdef DEBUG
	SmartDashboard::PutNumber("backRight Speed", speedValue);
#endif
	rotationValue = rotationValue * BACK_RIGHT_ROTATION_DIR;
	backRightMoveMotor->Set(speedValue * BACK_RIGHT_MOVEMENT_DIR);
	double encPos = backRightTurnMotor->GetEncPosition();
	encPos /= 1657;
	double temp = rotationValue;
	temp +=(int)encPos;
	encPos= encPos  - int(encPos);
	if ((rotationValue - encPos) > 0.5)
	{
		temp-=1;
	}
	else if ((rotationValue - encPos) < -0.5)
	{
		temp += 1;
	}
#ifdef DEBUG
	SmartDashboard::PutNumber("backRight Setpoint", temp);
#endif
	backRightTurnMotor->SetSetpoint(temp);
	backRightTurnMotor->Enable();
}

void Drivetrain::DriveBackLeft(double speedValue, double rotationValue)
{
#ifdef DEBUG
	SmartDashboard::PutNumber("backLeft Speed", speedValue);
#endif
	rotationValue = rotationValue * BACK_LEFT_ROTATION_DIR;
	backLeftMoveMotor->Set(speedValue * BACK_LEFT_MOVEMENT_DIR);
	double encPos = backLeftTurnMotor->GetEncPosition();
	encPos /= 1657;
	double temp = rotationValue;
	temp +=(int)encPos;
	encPos= encPos  - int(encPos);
	if ((rotationValue - encPos) > 0.5)
	{
		temp-=1;
	}
	else if ((rotationValue - encPos) < -0.5)
	{
		temp += 1;
	}
#ifdef DEBUG
	SmartDashboard::PutNumber("backLeft Setpoint", temp);
#endif
	backLeftTurnMotor->SetSetpoint(temp);
	backLeftTurnMotor->Enable();
}

void Drivetrain::IgnoreJoystickInput(bool value)
{
	IgnoreInput = value;
}

bool Drivetrain::GetIgnoreInput()
{
	return IgnoreInput;
}

double Drivetrain::GetYaw()
{
	return -pidgeotto->GetFusedHeading();
}
