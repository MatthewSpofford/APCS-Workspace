// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "TurnToAngle.h"
#include "stdio.h"
#include "../Robot.h"
#include "DriverStation.h"

static FILE *logfile = 0;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

TurnToAngle::TurnToAngle(double targetAngle, bool isTeleop): Command() {
        // Use requires() here to declare subsystem dependencies
    // eg. requires(Robot::chassis.get());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	m_targetAngle = targetAngle;
	Requires(Robot::drivetrain.get());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	IsTeleop = isTeleop;
}

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

// Called just before this Command runs the first time
void TurnToAngle::Initialize() {
	logfile = fopen("/tmp/4048New.log", "w");
	if(IsTeleop )
	{
		if(m_targetAngle == 0 && Robot::gearPickup->CompletedWallParallel == 0 && Robot::gearPickup->currentGateState == OPEN)
		{
			if(Robot::gearPickup->GetTargetAngle() != -1)
			{
				m_targetAngle = Robot::gearPickup->GetTargetAngle();
			}
			else
			{
				isFinished = true; //angle couldn't be calculated, abandon command
			}
		}
	}
	else if (m_targetAngle == 0) //this is only for the gear because its presumed that the boiler dumping will
								 //have a specific angle to turn to, not the default 0.
	{
		if(Robot::autoPosition == 0) //&& Robot::gearPickup->CompletedWallParallel == 0 && Robot::gearPickup->currentGateState == OPEN)
			m_targetAngle = -150;
		else if(Robot::autoPosition == 1) //&& Robot::gearPickup->CompletedWallParallel == 0 && Robot::gearPickup->currentGateState == OPEN)
			m_targetAngle = -90;
		else if(Robot:: autoPosition == 2) //&& Robot::gearPickup->CompletedWallParallel == 0 && Robot::gearPickup->currentGateState == OPEN)
			m_targetAngle = 150;
		//calculate angle based on driver station location for autonomous
		//left = -150 deg
		//right = 150 deg
		//middle = 90 deg

		//turning 90 so that gear subsystem faces the lift
	}
	SmartDashboard::PutNumber("Target Angle", m_targetAngle);
}

// Called repeatedly when this Command is scheduled to run
void TurnToAngle::Execute() {
	if(Robot::drivetrain->TurnToAngle(m_targetAngle) == 0)
		isFinished = true;
	else
		isFinished = false;
  
  if(!isFinished)
	  Robot::drivetrain->DriveControl(0, 0, Robot::drivetrain->TurnToAngle(m_targetAngle), false, true);
}

// Make this return true when this Command no longer needs to run execute()
bool TurnToAngle::IsFinished() {
    return isFinished;
}

// Called once after isFinished returns true
void TurnToAngle::End() {
	Robot::drivetrain->StopDrive();
}
// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void TurnToAngle::Interrupted() {
	Robot::drivetrain->StopDrive();
	//Robot::gearPickup->CompletedWallParallel = FAILURE;
}
